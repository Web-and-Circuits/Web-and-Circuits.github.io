<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#0f172a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Neurons‚ÜíAgents">
    <title>The Prediction Game - Understanding How AI Thinks</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1b69 100%);
            color: #e1e1e1;
            line-height: 1.6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .act {
            display: none;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        .act.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            color: #4ecdc4;
            margin: 2em 0 1em 0;
            font-size: 1.8em;
        }
        
        h3 {
            color: #ff6b6b;
            margin: 1.5em 0 1em 0;
        }
        
        .mystery-box {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #4ecdc4;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 12px;
            color: #e1e1e1;
            font-size: 16px;
            flex: 1;
            min-width: 200px;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #4ecdc4;
        }
        
        input[type="range"] {
            flex: 1;
            min-width: 150px;
        }
        
        .slider-value {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            height: 300px;
            position: relative;
        }
        
        .bar-chart {
            height: 100%;
            display: flex;
            align-items: end;
            gap: 8px;
            padding: 20px 0;
        }
        
        .bar {
            background: linear-gradient(to top, #ff6b6b, #4ecdc4);
            border-radius: 4px 4px 0 0;
            min-height: 5px;
            flex: 1;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .bar-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #ccc;
        }
        
        .bar-value {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #4ecdc4;
            font-weight: bold;
        }
        
        .navigation {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .code-editor {
            background: #1e1e1e;
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .code-header {
            background: #4ecdc4;
            color: #1e1e1e;
            padding: 10px 15px;
            font-weight: bold;
        }
        
        textarea {
            width: 100%;
            height: 200px;
            background: #1e1e1e;
            color: #e1e1e1;
            border: none;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            resize: vertical;
        }
        
        .test-results {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .test-case {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }
        
        .test-status {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .test-pass { background: #4ecdc4; color: #1e1e1e; }
        .test-fail { background: #ff6b6b; color: white; }
        .test-pending { background: #666; color: white; }
        
        .hint {
            background: rgba(255, 107, 107, 0.1);
            border-left: 4px solid #ff6b6b;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .quote {
            background: rgba(78, 205, 196, 0.1);
            border-left: 4px solid #4ecdc4;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            font-style: italic;
        }
        
        .side-by-side {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
        }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            h1 { font-size: 2em; }
            .control-group { flex-direction: column; align-items: stretch; }
            .side-by-side { grid-template-columns: 1fr; }
        }
        
        .progress {
            background: rgba(255, 255, 255, 0.1);
            height: 4px;
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ The Prediction Game</h1>
        <p style="text-align: center; font-size: 1.2em; margin-bottom: 2em;">
            Discover the secret behind every AI by playing the prediction game
        </p>
        
        <div class="progress">
            <div class="progress-bar" style="width: 33%;"></div>
        </div>
        
        <!-- Act 1: The Explorable -->
        <div class="act active" id="act1">
            <h2>üïµÔ∏è Act 1: The Mystery</h2>
            <p>Something strange is happening here. Type some words below and watch what happens...</p>
            
            <div class="mystery-box">
                <h3>üéÆ The Prediction Machine</h3>
                <p>Start typing and see if you can figure out the pattern:</p>
                
                <div class="controls">
                    <div class="control-group">
                        <label>Your text:</label>
                        <input type="text" id="text-input" placeholder="the quick brown" value="the quick">
                    </div>
                </div>
                
                <div class="chart-container">
                    <div class="bar-chart" id="probability-chart">
                        <!-- Bars will be generated by JavaScript -->
                    </div>
                </div>
                
                <p style="margin-top: 20px;">ü§î What do you think is happening here?</p>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <label>üå°Ô∏è Temperature:</label>
                    <input type="range" id="temperature" min="0" max="2" step="0.1" value="1">
                    <div class="slider-value" id="temp-value">1.0</div>
                </div>
                <div class="control-group">
                    <label>üî¢ Top-K:</label>
                    <input type="range" id="top-k" min="1" max="10" step="1" value="5">
                    <div class="slider-value" id="topk-value">5</div>
                </div>
            </div>
            
            <div class="mystery-box">
                <h3>üé≤ Generated Text</h3>
                <div id="generated-text" style="font-family: monospace; font-size: 1.1em; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; min-height: 60px;">
                    Click the generate button to see what happens!
                </div>
                <button onclick="generateText()" style="margin-top: 15px;">üé≤ Generate Next Words</button>
            </div>
            
            <div class="navigation">
                <button onclick="nextAct()">I think I understand... ‚Üí</button>
            </div>
        </div>
        
        <!-- Act 2: The Build -->
        <div class="act" id="act2">
            <h2>üõ†Ô∏è Act 2: Build It Yourself</h2>
            <p>Now that you've seen the pattern, let's build the machine from scratch! You'll write real Python code that does exactly what you just experienced.</p>
            
            <div class="quote">
                <strong>From "Build a Large Language Model (From Scratch)" by Sebastian Raschka:</strong><br>
                "Models like this often have tens or even hundreds of billions of parameters, which are the adjustable weights in the network that are optimized during training to predict the next word in a sequence. Next-word prediction is sensible because it harnesses the inherent sequential nature of language to train models on understanding context, structure, and relationships within text."
            </div>
            
            <div id="puzzle-container">
                <!-- Puzzles will be loaded here by JavaScript -->
            </div>
            
            <div class="navigation">
                <button onclick="prevAct()">‚Üê Back to Exploration</button>
                <button onclick="nextAct()">I built it! What's next? ‚Üí</button>
            </div>
        </div>
        
        <!-- Act 3: The Connection -->
        <div class="act" id="act3">
            <h2>üîó Act 3: The Big Reveal</h2>
            
            <div class="mystery-box">
                <h1 style="font-size: 2em; margin-bottom: 20px;">üéâ Congratulations!</h1>
                <p style="font-size: 1.3em;">You just built the core of every Large Language Model.</p>
                <p>The only difference is: <strong>real models use transformers instead of bigrams to compute those probabilities.</strong></p>
            </div>
            
            <div class="quote">
                <strong>The Secret:</strong><br>
                "Next-word prediction is sensible because it harnesses the inherent sequential nature of language to train models on understanding context, structure, and relationships within text. It is a very simple task, and so it is surprising to many researchers that it can produce such capable models." - Sebastian Raschka
            </div>
            
            <h3>Your Model vs. Real AI</h3>
            <div class="side-by-side">
                <div class="comparison-box">
                    <h4 style="color: #ff6b6b;">üìù Your Bigram Model</h4>
                    <p><strong>Looks at:</strong> Just the previous word</p>
                    <p><strong>Training data:</strong> Small Shakespeare excerpt</p>
                    <p><strong>Parameters:</strong> ~1,000</p>
                    <div id="your-model-demo" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin-top: 10px; font-family: monospace;">
                        the quick ‚Üí [brown: 60%, red: 30%, blue: 10%]
                    </div>
                </div>
                <div class="comparison-box">
                    <h4 style="color: #4ecdc4;">ü§ñ GPT-4</h4>
                    <p><strong>Looks at:</strong> Entire context (1000s of words)</p>
                    <p><strong>Training data:</strong> Most of the internet</p>
                    <p><strong>Parameters:</strong> ~1.7 trillion</p>
                    <div id="gpt-model-demo" style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin-top: 10px; font-family: monospace;">
                        the quick ‚Üí [brown: 45%, fox: 25%, response: 20%, ...]
                    </div>
                </div>
            </div>
            
            <h3>üé• Learn More</h3>
            <p>Watch Andrej Karpathy explain how transformers compute those probabilities:</p>
            <!-- Video clips would go here when available -->
            <div style="background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 10px; margin: 20px 0;">
                <p><strong>üé¨ Video clips coming soon:</strong></p>
                <p>‚Ä¢ Karpathy explaining context ‚Üí probability distribution (16:39-17:35)</p>
                <p>‚Ä¢ Stochastic sampling explanation (28:20-28:50)</p>
            </div>
            
            <h3>üöÄ What's Next?</h3>
            <ul style="margin: 20px 0; padding-left: 20px;">
                <li>Learn about the transformer architecture</li>
                <li>Understand attention mechanisms</li>
                <li>Explore training on massive datasets</li>
                <li>Build your own mini-GPT</li>
            </ul>
            
            <div class="navigation">
                <button onclick="prevAct()">‚Üê Back to Building</button>
                <button onclick="restartJourney()">üîÑ Start Over</button>
            </div>
        </div>
    </div>
    
    <!-- Load Pyodide for Python execution -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    
    <script>
        // Hardcoded bigram model based on Shakespeare
        const bigramModel = {
            'the': {'quick': 0.4, 'king': 0.25, 'sun': 0.15, 'old': 0.1, 'great': 0.1},
            'quick': {'brown': 0.6, 'red': 0.25, 'silver': 0.15},
            'brown': {'fox': 0.7, 'dog': 0.2, 'bear': 0.1},
            'king': {'of': 0.5, 'is': 0.3, 'said': 0.2},
            'of': {'england': 0.4, 'france': 0.3, 'the': 0.2, 'spain': 0.1},
            'is': {'dead': 0.4, 'alive': 0.3, 'here': 0.3},
            'sun': {'shines': 0.5, 'sets': 0.3, 'rises': 0.2},
            'old': {'man': 0.6, 'king': 0.3, 'tree': 0.1},
            'great': {'king': 0.4, 'war': 0.3, 'hall': 0.3},
            'fox': {'jumps': 0.7, 'runs': 0.3},
            'jumps': {'over': 0.9, 'high': 0.1},
            'over': {'the': 0.8, 'a': 0.2},
            'dog': {'barks': 0.6, 'sleeps': 0.4},
            'red': {'rose': 0.5, 'sun': 0.3, 'blood': 0.2},
            'silver': {'moon': 0.6, 'sword': 0.4}
        };
        
        let currentAct = 1;
        let pyodideReady = false;
        let pyodide = null;
        
        // Initialize Pyodide
        async function initPyodide() {
            if (!pyodideReady) {
                try {
                    pyodide = await loadPyodide();
                    pyodideReady = true;
                    console.log("Pyodide loaded successfully");
                } catch (error) {
                    console.error("Failed to load Pyodide:", error);
                }
            }
        }
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            initPyodide();
            updateChart();
            setupEventListeners();
            initializePuzzles();
        });
        
        function setupEventListeners() {
            document.getElementById('text-input').addEventListener('input', updateChart);
            document.getElementById('temperature').addEventListener('input', function() {
                document.getElementById('temp-value').textContent = this.value;
                updateChart();
            });
            document.getElementById('top-k').addEventListener('input', function() {
                document.getElementById('topk-value').textContent = this.value;
                updateChart();
            });
        }
        
        function applyTemperature(probabilities, temperature) {
            if (temperature === 0) {
                // Always pick the highest probability
                const maxKey = Object.keys(probabilities).reduce((a, b) => 
                    probabilities[a] > probabilities[b] ? a : b);
                const result = {};
                result[maxKey] = 1.0;
                return result;
            }
            
            // Apply temperature scaling
            const scaled = {};
            for (const [word, prob] of Object.entries(probabilities)) {
                scaled[word] = Math.pow(prob, 1 / temperature);
            }
            
            // Normalize
            const sum = Object.values(scaled).reduce((a, b) => a + b, 0);
            for (const word in scaled) {
                scaled[word] /= sum;
            }
            
            return scaled;
        }
        
        function applyTopK(probabilities, k) {
            const sorted = Object.entries(probabilities)
                .sort(([,a], [,b]) => b - a)
                .slice(0, k);
            
            const result = {};
            const sum = sorted.reduce((acc, [, prob]) => acc + prob, 0);
            
            for (const [word, prob] of sorted) {
                result[word] = prob / sum;
            }
            
            return result;
        }
        
        function updateChart() {
            const input = document.getElementById('text-input').value.trim();
            const temperature = parseFloat(document.getElementById('temperature').value);
            const topK = parseInt(document.getElementById('top-k').value);
            
            const words = input.split(' ');
            const lastWord = words[words.length - 1].toLowerCase();
            
            let probabilities = bigramModel[lastWord] || {'?': 1.0};
            
            // Apply temperature
            probabilities = applyTemperature(probabilities, temperature);
            
            // Apply top-k filtering
            probabilities = applyTopK(probabilities, topK);
            
            const chartContainer = document.getElementById('probability-chart');
            chartContainer.innerHTML = '';
            
            const maxProb = Math.max(...Object.values(probabilities));
            
            for (const [word, prob] of Object.entries(probabilities)) {
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${(prob / maxProb) * 100}%`;
                
                const label = document.createElement('div');
                label.className = 'bar-label';
                label.textContent = word;
                
                const value = document.createElement('div');
                value.className = 'bar-value';
                value.textContent = `${(prob * 100).toFixed(1)}%`;
                
                bar.appendChild(label);
                bar.appendChild(value);
                chartContainer.appendChild(bar);
            }
        }
        
        function weightedRandomChoice(probabilities) {
            const random = Math.random();
            let cumulative = 0;
            
            for (const [word, prob] of Object.entries(probabilities)) {
                cumulative += prob;
                if (random <= cumulative) {
                    return word;
                }
            }
            
            // Fallback
            return Object.keys(probabilities)[0];
        }
        
        function generateText() {
            const input = document.getElementById('text-input').value.trim();
            const temperature = parseFloat(document.getElementById('temperature').value);
            const topK = parseInt(document.getElementById('top-k').value);
            
            let words = input.split(' ').filter(w => w.length > 0);
            const maxWords = 20;
            let generatedCount = 0;
            
            while (generatedCount < 10 && words.length < maxWords) {
                const lastWord = words[words.length - 1].toLowerCase();
                let probabilities = bigramModel[lastWord];
                
                if (!probabilities) break;
                
                probabilities = applyTemperature(probabilities, temperature);
                probabilities = applyTopK(probabilities, topK);
                
                const nextWord = weightedRandomChoice(probabilities);
                words.push(nextWord);
                generatedCount++;
            }
            
            document.getElementById('generated-text').textContent = words.join(' ');
        }
        
        function nextAct() {
            if (currentAct < 3) {
                document.getElementById(`act${currentAct}`).classList.remove('active');
                currentAct++;
                document.getElementById(`act${currentAct}`).classList.add('active');
                
                // Update progress bar
                const progressBar = document.querySelector('.progress-bar');
                progressBar.style.width = `${(currentAct / 3) * 100}%`;
                
                // Initialize puzzles when entering Act 2
                if (currentAct === 2) {
                    loadNextPuzzle();
                }
            }
        }
        
        function prevAct() {
            if (currentAct > 1) {
                document.getElementById(`act${currentAct}`).classList.remove('active');
                currentAct--;
                document.getElementById(`act${currentAct}`).classList.add('active');
                
                // Update progress bar
                const progressBar = document.querySelector('.progress-bar');
                progressBar.style.width = `${(currentAct / 3) * 100}%`;
            }
        }
        
        function restartJourney() {
            document.getElementById(`act${currentAct}`).classList.remove('active');
            currentAct = 1;
            document.getElementById('act1').classList.add('active');
            
            // Reset progress bar
            const progressBar = document.querySelector('.progress-bar');
            progressBar.style.width = '33%';
            
            // Reset puzzle state
            currentPuzzle = 0;
        }
        
        // Puzzle system for Act 2
        const puzzles = [
            {
                title: "üî¢ Count the Pairs",
                description: "Build a function that counts how often each word follows another word. This is called a 'bigram counter'.",
                hint: "What's the simplest version? Try counting just one pair first: ('the', 'quick'). How many times does 'quick' follow 'the'?",
                skeleton: `def count_bigrams(text):
    """Count how often each word follows another word"""
    words = text.lower().split()
    bigrams = {}
    
    # Your code here!
    # Loop through pairs of words and count them
    
    return bigrams

# Test with sample text
sample_text = "the quick brown fox jumps over the lazy dog the dog barks"
result = count_bigrams(sample_text)
print(result)`,
                solution: `def count_bigrams(text):
    words = text.lower().split()
    bigrams = {}
    
    for i in range(len(words) - 1):
        first_word = words[i]
        second_word = words[i + 1]
        
        if first_word not in bigrams:
            bigrams[first_word] = {}
        if second_word not in bigrams[first_word]:
            bigrams[first_word][second_word] = 0
        
        bigrams[first_word][second_word] += 1
    
    return bigrams`,
                tests: [
                    {
                        input: "the quick brown",
                        expected: "bigrams['the']['quick'] should equal 1"
                    },
                    {
                        input: "the dog the dog",
                        expected: "bigrams['the']['dog'] should equal 2"
                    }
                ]
            },
            {
                title: "üìä Turn Counts into Probabilities", 
                description: "Convert raw counts into probabilities. If 'quick' follows 'the' 3 times out of 6, that's a 50% probability.",
                hint: "For each first word, divide each count by the total number of times that first word appears.",
                skeleton: `def counts_to_probabilities(bigram_counts):
    """Convert counts to probabilities"""
    probabilities = {}
    
    # Your code here!
    # For each word, normalize its follower counts
    
    return probabilities

# Test
counts = {'the': {'quick': 2, 'brown': 1}, 'quick': {'brown': 3}}
result = counts_to_probabilities(counts)
print(result)`,
                solution: `def counts_to_probabilities(bigram_counts):
    probabilities = {}
    
    for first_word, followers in bigram_counts.items():
        total_count = sum(followers.values())
        probabilities[first_word] = {}
        
        for second_word, count in followers.items():
            probabilities[first_word][second_word] = count / total_count
    
    return probabilities`,
                tests: [
                    {
                        input: "{'the': {'quick': 2, 'brown': 2}}",
                        expected: "Each probability should be 0.5"
                    }
                ]
            },
            {
                title: "üé≤ Sample the Next Word",
                description: "Given probabilities, randomly choose the next word. Higher probability = more likely to be chosen.",
                hint: "Generate a random number between 0 and 1. Walk through the probabilities, adding them up until you exceed the random number.",
                skeleton: `import random

def sample_next_word(probabilities):
    """Randomly sample based on probabilities"""
    # Your code here!
    # Use random.random() to get a number between 0 and 1
    # Walk through probabilities until you exceed this number
    
    pass

# Test
probs = {'brown': 0.6, 'red': 0.3, 'blue': 0.1}
for i in range(5):
    print(sample_next_word(probs))`,
                solution: `import random

def sample_next_word(probabilities):
    rand = random.random()
    cumulative = 0
    
    for word, prob in probabilities.items():
        cumulative += prob
        if rand <= cumulative:
            return word
    
    # Fallback (shouldn't happen with proper probabilities)
    return list(probabilities.keys())[0]`,
                tests: [
                    {
                        input: "{'word': 1.0}",
                        expected: "Should always return 'word'"
                    }
                ]
            },
            {
                title: "üå°Ô∏è Add Temperature",
                description: "Modify probabilities with temperature. Temperature 0 = always pick the most likely. Temperature > 1 = more random.",
                hint: "Raise each probability to the power of (1/temperature), then normalize so they sum to 1.",
                skeleton: `def apply_temperature(probabilities, temperature):
    """Apply temperature scaling to probabilities"""
    if temperature == 0:
        # Always pick the most likely word
        # Your code here!
        pass
    
    # Scale probabilities by temperature
    # Your code here!
    
    return probabilities

# Test
probs = {'brown': 0.6, 'red': 0.3, 'blue': 0.1}
print("Original:", probs)
print("Temp 0.5:", apply_temperature(probs, 0.5))
print("Temp 2.0:", apply_temperature(probs, 2.0))`,
                solution: `def apply_temperature(probabilities, temperature):
    if temperature == 0:
        max_word = max(probabilities, key=probabilities.get)
        return {max_word: 1.0}
    
    scaled = {}
    for word, prob in probabilities.items():
        scaled[word] = prob ** (1 / temperature)
    
    # Normalize
    total = sum(scaled.values())
    for word in scaled:
        scaled[word] /= total
    
    return scaled`,
                tests: [
                    {
                        input: "temp=0",
                        expected: "Should return only the most probable word"
                    }
                ]
            },
            {
                title: "üìù Generate a Sentence",
                description: "Chain everything together! Generate a complete sentence by repeatedly predicting the next word.",
                hint: "Start with a seed word. Use your bigram model to get probabilities, apply temperature, sample the next word, then repeat!",
                skeleton: `def generate_sentence(bigram_probs, seed_word, max_length=10, temperature=1.0):
    """Generate a sentence using the bigram model"""
    sentence = [seed_word]
    
    # Your code here!
    # Loop and keep adding words until max_length or no more possibilities
    
    return ' '.join(sentence)

# You'll need your bigram probabilities from earlier puzzles
# For testing, use this simple model:
model = {
    'the': {'quick': 0.5, 'brown': 0.5},
    'quick': {'brown': 1.0},
    'brown': {'fox': 1.0}
}

print(generate_sentence(model, 'the', max_length=5))`,
                solution: `def generate_sentence(bigram_probs, seed_word, max_length=10, temperature=1.0):
    sentence = [seed_word]
    current_word = seed_word
    
    for _ in range(max_length - 1):
        if current_word not in bigram_probs:
            break
        
        probs = bigram_probs[current_word].copy()
        probs = apply_temperature(probs, temperature)
        
        next_word = sample_next_word(probs)
        sentence.append(next_word)
        current_word = next_word
    
    return ' '.join(sentence)`,
                tests: [
                    {
                        input: "Should generate coherent text",
                        expected: "Words should follow the bigram model"
                    }
                ]
            }
        ];
        
        let currentPuzzle = 0;
        
        function initializePuzzles() {
            // This will be called when Act 2 is first shown
        }
        
        function loadNextPuzzle() {
            if (currentPuzzle >= puzzles.length) {
                document.getElementById('puzzle-container').innerHTML = `
                    <div class="mystery-box">
                        <h2>üéâ All Puzzles Complete!</h2>
                        <p>You've successfully built a complete language model from scratch! Every word prediction you see in ChatGPT, Claude, or GPT-4 works on this exact same principle - they just use transformers instead of bigrams to compute those probabilities.</p>
                    </div>
                `;
                return;
            }
            
            const puzzle = puzzles[currentPuzzle];
            document.getElementById('puzzle-container').innerHTML = `
                <div class="code-editor">
                    <div class="code-header">
                        Puzzle ${currentPuzzle + 1}/5: ${puzzle.title}
                    </div>
                    <div style="padding: 20px;">
                        <p>${puzzle.description}</p>
                        <div class="hint">
                            üí° <strong>Hint:</strong> ${puzzle.hint}
                        </div>
                        <textarea id="code-input" placeholder="Write your code here...">${puzzle.skeleton}</textarea>
                        <div style="margin-top: 10px;">
                            <button onclick="runPuzzleCode()">‚ñ∂Ô∏è Run Code</button>
                            <button onclick="showSolution()">üí° Show Solution</button>
                            <button onclick="nextPuzzle()">‚û°Ô∏è Next Puzzle</button>
                        </div>
                        <div class="test-results" id="test-results">
                            <div class="test-case">
                                <div class="test-status test-pending">?</div>
                                <span>Tests will appear here when you run your code</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        async function runPuzzleCode() {
            if (!pyodideReady) {
                alert("Python environment is still loading. Please wait a moment and try again.");
                return;
            }
            
            const code = document.getElementById('code-input').value;
            const resultsContainer = document.getElementById('test-results');
            
            try {
                // Clear previous results and capture output
                pyodide.runPython(`
import sys
from io import StringIO
old_stdout = sys.stdout
sys.stdout = StringIO()
                `);
                
                // Run user code
                pyodide.runPython(code);
                
                // Get output
                const output = pyodide.runPython(`
result = sys.stdout.getvalue()
sys.stdout = old_stdout
result
                `);
                
                resultsContainer.innerHTML = `
                    <div class="test-case">
                        <div class="test-status test-pass">‚úì</div>
                        <span>Code ran successfully!</span>
                    </div>
                    <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin-top: 10px; font-family: monospace; white-space: pre-wrap;">${output}</div>
                `;
                
            } catch (error) {
                resultsContainer.innerHTML = `
                    <div class="test-case">
                        <div class="test-status test-fail">‚úó</div>
                        <span>Error: ${error.message}</span>
                    </div>
                `;
            }
        }
        
        function showSolution() {
            const puzzle = puzzles[currentPuzzle];
            document.getElementById('code-input').value = puzzle.solution;
        }
        
        function nextPuzzle() {
            currentPuzzle++;
            loadNextPuzzle();
        }
    </script>
</body>
</html>