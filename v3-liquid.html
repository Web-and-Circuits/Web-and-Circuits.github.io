<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Web and Circuits LLC — Liquid</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0f0f0f;
  min-height: 100vh;
  overflow: hidden;
  font-family: 'Syne', sans-serif;
}

#gradient-canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
}

.noise {
  position: fixed;
  inset: 0;
  z-index: 1;
  opacity: 0.03;
  pointer-events: none;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
}

.content {
  position: relative;
  z-index: 10;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 40px;
  color: white;
}

.logo-container {
  margin-bottom: 40px;
}

.blob-logo {
  width: 120px;
  height: 120px;
  position: relative;
}

.blob-logo svg {
  width: 100%;
  height: 100%;
  filter: url(#goo);
}

.blob-circle {
  fill: url(#blob-gradient);
  transform-origin: center;
}

h1 {
  font-size: clamp(56px, 12vw, 140px);
  font-weight: 800;
  letter-spacing: -0.05em;
  line-height: 0.9;
  margin-bottom: 24px;
  mix-blend-mode: difference;
}

.tagline {
  font-size: clamp(18px, 3vw, 28px);
  font-weight: 400;
  color: rgba(255,255,255,0.7);
  max-width: 600px;
  line-height: 1.5;
  margin-bottom: 56px;
}

.buttons {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn {
  padding: 20px 40px;
  border-radius: 100px;
  font-family: inherit;
  font-size: 16px;
  font-weight: 600;
  text-decoration: none;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.btn-blob {
  background: white;
  color: #0f0f0f;
  border: none;
}

.btn-blob:hover {
  transform: scale(1.05);
  box-shadow: 0 20px 60px rgba(255,255,255,0.3);
}

.btn-outline {
  background: transparent;
  color: white;
  border: 2px solid rgba(255,255,255,0.3);
}

.btn-outline:hover {
  border-color: white;
  background: rgba(255,255,255,0.1);
}

/* Interactive blob that follows cursor */
.cursor-blob {
  position: fixed;
  width: 400px;
  height: 400px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255,100,100,0.4) 0%, transparent 70%);
  pointer-events: none;
  z-index: 2;
  filter: blur(40px);
  transition: transform 0.1s ease-out;
  mix-blend-mode: screen;
}

/* Morphing shape in corner */
.corner-shape {
  position: fixed;
  width: 600px;
  height: 600px;
  z-index: 1;
  pointer-events: none;
}

.corner-shape.top-right {
  top: -200px;
  right: -200px;
}

.corner-shape.bottom-left {
  bottom: -200px;
  left: -200px;
}

/* Links strip */
.links-strip {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 40px;
  z-index: 20;
}

.links-strip a {
  color: rgba(255,255,255,0.5);
  text-decoration: none;
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 0.05em;
  transition: color 0.3s;
}

.links-strip a:hover {
  color: white;
}

/* Floating orbs */
.orbs {
  position: fixed;
  inset: 0;
  z-index: 1;
  pointer-events: none;
  overflow: hidden;
}

.orb {
  position: absolute;
  border-radius: 50%;
  filter: blur(60px);
  animation: float-orb 20s ease-in-out infinite;
}

@keyframes float-orb {
  0%, 100% { transform: translate(0, 0) scale(1); }
  25% { transform: translate(50px, -30px) scale(1.1); }
  50% { transform: translate(-30px, 50px) scale(0.9); }
  75% { transform: translate(-50px, -20px) scale(1.05); }
}
</style>
</head>
<body>

<canvas id="gradient-canvas"></canvas>
<div class="noise"></div>

<div class="orbs">
  <div class="orb" style="width: 500px; height: 500px; background: rgba(255,50,100,0.3); top: 10%; left: 60%; animation-delay: 0s;"></div>
  <div class="orb" style="width: 400px; height: 400px; background: rgba(100,50,255,0.3); top: 50%; left: 20%; animation-delay: -5s;"></div>
  <div class="orb" style="width: 300px; height: 300px; background: rgba(50,200,255,0.3); top: 70%; left: 70%; animation-delay: -10s;"></div>
</div>

<div class="cursor-blob" id="cursor-blob"></div>

<div class="content">
  <div class="logo-container">
    <svg class="blob-logo" viewBox="0 0 100 100">
      <defs>
        <filter id="goo">
          <feGaussianBlur in="SourceGraphic" stdDeviation="4" result="blur"/>
          <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo"/>
        </filter>
        <linearGradient id="blob-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" style="stop-color:#ff6b6b"/>
          <stop offset="50%" style="stop-color:#a855f7"/>
          <stop offset="100%" style="stop-color:#3b82f6"/>
        </linearGradient>
      </defs>
      <g filter="url(#goo)">
        <circle class="blob-circle" cx="35" cy="35" r="20">
          <animate attributeName="cx" values="35;45;35;25;35" dur="4s" repeatCount="indefinite"/>
          <animate attributeName="cy" values="35;25;45;35;35" dur="4s" repeatCount="indefinite"/>
        </circle>
        <circle class="blob-circle" cx="65" cy="35" r="18">
          <animate attributeName="cx" values="65;55;65;75;65" dur="3.5s" repeatCount="indefinite"/>
          <animate attributeName="cy" values="35;45;25;35;35" dur="3.5s" repeatCount="indefinite"/>
        </circle>
        <circle class="blob-circle" cx="50" cy="65" r="22">
          <animate attributeName="cx" values="50;60;40;50;50" dur="4.5s" repeatCount="indefinite"/>
          <animate attributeName="cy" values="65;55;65;75;65" dur="4.5s" repeatCount="indefinite"/>
        </circle>
      </g>
    </svg>
  </div>
  
  <h1>Web &<br>Circuits LLC</h1>
  
  <p class="tagline">
    Where human creativity flows into machine intelligence.
    Fluid. Open. Evolving.
  </p>
  
  <div class="buttons">
    <a href="/heartbeat-demo" class="btn btn-blob">Explore Projects</a>
    <a href="/lab/" class="btn btn-outline">The Lab</a>
    <a href="https://github.com/Web-and-Circuits" class="btn btn-outline">GitHub</a>
  </div>
</div>

<div class="links-strip">
  <a href="https://github.com/Web-and-Circuits">GitHub</a>
  <a href="/heartbeat-demo">Heartbeat Demo</a>
</div>

<script>
// ═══════════════════════════════════════════════════════
// ANIMATED GRADIENT MESH (WebGL Shader)
// ═══════════════════════════════════════════════════════

const canvas = document.getElementById('gradient-canvas');
const gl = canvas.getContext('webgl');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

// Vertex shader
const vertexShaderSource = `
  attribute vec2 position;
  void main() {
    gl_Position = vec4(position, 0.0, 1.0);
  }
`;

// Fragment shader - Metaball/liquid effect
const fragmentShaderSource = `
  precision highp float;
  uniform vec2 resolution;
  uniform float time;
  uniform vec2 mouse;
  
  #define NUM_BLOBS 6
  
  vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.0, 0.1, 0.2);
    return a + b * cos(6.28318 * (c * t + d));
  }
  
  float metaball(vec2 p, vec2 center, float radius) {
    float d = length(p - center);
    return radius / (d * d + 0.001);
  }
  
  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = (gl_FragCoord.xy - 0.5 * resolution) / min(resolution.x, resolution.y);
    
    float value = 0.0;
    
    // Animated blob positions
    vec2 blobs[NUM_BLOBS];
    blobs[0] = vec2(sin(time * 0.3) * 0.4, cos(time * 0.4) * 0.3);
    blobs[1] = vec2(cos(time * 0.5) * 0.3, sin(time * 0.3) * 0.4);
    blobs[2] = vec2(sin(time * 0.4 + 2.0) * 0.35, cos(time * 0.35 + 1.0) * 0.35);
    blobs[3] = vec2(cos(time * 0.35 + 3.0) * 0.4, sin(time * 0.45 + 2.0) * 0.3);
    blobs[4] = vec2(sin(time * 0.45 + 4.0) * 0.3, cos(time * 0.5 + 3.0) * 0.4);
    blobs[5] = (mouse - 0.5) * 2.0; // Mouse-controlled blob
    
    float sizes[NUM_BLOBS];
    sizes[0] = 0.15;
    sizes[1] = 0.12;
    sizes[2] = 0.1;
    sizes[3] = 0.13;
    sizes[4] = 0.11;
    sizes[5] = 0.08;
    
    for (int i = 0; i < NUM_BLOBS; i++) {
      value += metaball(p, blobs[i], sizes[i]);
    }
    
    // Create liquid threshold
    float threshold = smoothstep(0.8, 1.2, value);
    
    // Color based on value
    vec3 color1 = vec3(0.9, 0.2, 0.3); // Red
    vec3 color2 = vec3(0.6, 0.2, 0.9); // Purple
    vec3 color3 = vec3(0.2, 0.4, 0.9); // Blue
    
    vec3 color = mix(color1, color2, sin(value + time * 0.5) * 0.5 + 0.5);
    color = mix(color, color3, cos(value * 2.0 + time * 0.3) * 0.5 + 0.5);
    
    // Add glow
    float glow = smoothstep(0.5, 1.5, value) * 0.5;
    
    // Background
    vec3 bg = vec3(0.06);
    
    // Final mix
    vec3 finalColor = mix(bg, color * 0.8, threshold + glow);
    
    // Vignette
    float vignette = 1.0 - length(uv - 0.5) * 0.8;
    finalColor *= vignette;
    
    gl_FragColor = vec4(finalColor, 1.0);
  }
`;

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Full-screen quad
const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

const positionLocation = gl.getAttribLocation(program, 'position');
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

const resolutionLocation = gl.getUniformLocation(program, 'resolution');
const timeLocation = gl.getUniformLocation(program, 'time');
const mouseLocation = gl.getUniformLocation(program, 'mouse');

let mouse = { x: 0.5, y: 0.5 };

document.addEventListener('mousemove', (e) => {
  mouse.x = e.clientX / window.innerWidth;
  mouse.y = 1.0 - e.clientY / window.innerHeight;
});

function render(time) {
  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
  gl.uniform1f(timeLocation, time * 0.001);
  gl.uniform2f(mouseLocation, mouse.x, mouse.y);
  
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);
}

render(0);

// ═══════════════════════════════════════════════════════
// CURSOR BLOB
// ═══════════════════════════════════════════════════════

const cursorBlob = document.getElementById('cursor-blob');
let blobX = 0, blobY = 0;
let targetX = 0, targetY = 0;

document.addEventListener('mousemove', (e) => {
  targetX = e.clientX - 200;
  targetY = e.clientY - 200;
});

function animateBlob() {
  blobX += (targetX - blobX) * 0.08;
  blobY += (targetY - blobY) * 0.08;
  cursorBlob.style.transform = `translate(${blobX}px, ${blobY}px)`;
  requestAnimationFrame(animateBlob);
}

animateBlob();
</script>
</body>
</html>
