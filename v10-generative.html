<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Web and Circuits LLC — Generative</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #000;
  min-height: 100vh;
  font-family: 'DM Sans', sans-serif;
  color: white;
  overflow: hidden;
}

#canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
}

.content {
  position: relative;
  z-index: 10;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
}

h1 {
  font-size: clamp(48px, 10vw, 120px);
  font-weight: 700;
  letter-spacing: -0.04em;
  mix-blend-mode: difference;
  margin-bottom: 16px;
}

.tagline {
  font-size: clamp(14px, 2vw, 20px);
  opacity: 0.7;
  margin-bottom: 48px;
  mix-blend-mode: difference;
}

.buttons {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn {
  padding: 16px 32px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  text-decoration: none;
  border-radius: 100px;
  transition: all 0.3s;
  cursor: pointer;
  mix-blend-mode: difference;
}

.btn-primary {
  background: white;
  color: black;
  border: none;
}

.btn-primary:hover {
  transform: scale(1.05);
}

.btn-outline {
  background: transparent;
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
}

.btn-outline:hover {
  border-color: white;
  background: rgba(255,255,255,0.1);
}

/* Controls */
.controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 100;
  background: rgba(0,0,0,0.5);
  padding: 12px 20px;
  border-radius: 100px;
  backdrop-filter: blur(10px);
}

.control-btn {
  background: transparent;
  border: 1px solid rgba(255,255,255,0.3);
  color: white;
  padding: 8px 16px;
  font-family: inherit;
  font-size: 12px;
  border-radius: 100px;
  cursor: pointer;
  transition: all 0.2s;
}

.control-btn:hover {
  background: rgba(255,255,255,0.1);
  border-color: white;
}

.control-btn.active {
  background: white;
  color: black;
}

/* Seed display */
.seed-display {
  position: fixed;
  top: 20px;
  left: 20px;
  font-size: 11px;
  font-family: monospace;
  opacity: 0.4;
  z-index: 100;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="content">
  <h1>Web and Circuits LLC</h1>
  <p class="tagline">Every visit, a new creation. Reload for another.</p>
  
  <div class="buttons">
    <a href="/heartbeat-demo" class="btn btn-primary">Explore Projects</a>
    <a href="https://github.com/Web-and-Circuits" class="btn btn-outline">View Code</a>
  </div>
</div>

<div class="controls">
  <button class="control-btn active" data-mode="flow">Flow Field</button>
  <button class="control-btn" data-mode="circles">Circles</button>
  <button class="control-btn" data-mode="mesh">Mesh</button>
  <button class="control-btn" data-mode="waves">Waves</button>
  <button class="control-btn" id="regenerate">↻ New</button>
</div>

<div class="seed-display" id="seed">seed: </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let seed = Math.random() * 10000 | 0;
let currentMode = 'flow';
let animationId;

// Seeded random
function seededRandom() {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280;
}

function random(min = 0, max = 1) {
  return min + seededRandom() * (max - min);
}

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}

resize();
window.addEventListener('resize', () => {
  resize();
  generate();
});

// Color palettes
const palettes = [
  ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'],
  ['#a8e6cf', '#dcedc1', '#ffd3b6', '#ffaaa5', '#ff8b94'],
  ['#2d3436', '#636e72', '#b2bec3', '#dfe6e9', '#74b9ff'],
  ['#6c5ce7', '#a29bfe', '#fd79a8', '#f8a5c2', '#f5cd79'],
  ['#00b894', '#00cec9', '#0984e3', '#6c5ce7', '#e84393'],
  ['#1a1a2e', '#16213e', '#0f3460', '#e94560', '#533483'],
];

let palette;

function choosePalette() {
  const index = Math.floor(random(0, palettes.length));
  palette = palettes[index];
}

// ═══════════════════════════════════════════════════════
// FLOW FIELD
// ═══════════════════════════════════════════════════════

function drawFlowField() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  const scale = random(0.002, 0.008);
  const particles = [];
  const numParticles = 2000;
  
  for (let i = 0; i < numParticles; i++) {
    particles.push({
      x: random(0, width),
      y: random(0, height),
      vx: 0,
      vy: 0,
      color: palette[Math.floor(random(0, palette.length))],
      life: random(50, 200)
    });
  }
  
  function noise(x, y) {
    return Math.sin(x * scale * 3) * Math.cos(y * scale * 2) + 
           Math.sin(x * scale + y * scale) * 0.5;
  }
  
  function animate() {
    ctx.fillStyle = 'rgba(10, 10, 10, 0.02)';
    ctx.fillRect(0, 0, width, height);
    
    particles.forEach(p => {
      const angle = noise(p.x, p.y) * Math.PI * 4;
      p.vx = Math.cos(angle) * 2;
      p.vy = Math.sin(angle) * 2;
      
      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      
      if (p.life <= 0 || p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
        p.x = random(0, width);
        p.y = random(0, height);
        p.life = random(50, 200);
      }
      
      ctx.beginPath();
      ctx.arc(p.x, p.y, 1, 0, Math.PI * 2);
      ctx.fillStyle = p.color + '80';
      ctx.fill();
    });
    
    animationId = requestAnimationFrame(animate);
  }
  
  animate();
}

// ═══════════════════════════════════════════════════════
// PACKING CIRCLES
// ═══════════════════════════════════════════════════════

function drawCircles() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  const circles = [];
  const maxAttempts = 5000;
  const minRadius = 5;
  const maxRadius = 100;
  
  for (let i = 0; i < maxAttempts; i++) {
    const x = random(0, width);
    const y = random(0, height);
    let radius = maxRadius;
    
    // Find max radius that doesn't overlap
    for (const c of circles) {
      const dist = Math.hypot(x - c.x, y - c.y);
      const maxR = dist - c.radius - 2;
      if (maxR < radius) radius = maxR;
    }
    
    // Check edges
    radius = Math.min(radius, x, y, width - x, height - y);
    
    if (radius >= minRadius) {
      circles.push({ x, y, radius, color: palette[Math.floor(random(0, palette.length))] });
    }
  }
  
  // Animate circles appearing
  let drawn = 0;
  
  function animate() {
    if (drawn >= circles.length) {
      animationId = requestAnimationFrame(animate);
      return;
    }
    
    const batchSize = Math.ceil(circles.length / 60);
    for (let i = 0; i < batchSize && drawn < circles.length; i++, drawn++) {
      const c = circles[drawn];
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
      ctx.strokeStyle = c.color;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    animationId = requestAnimationFrame(animate);
  }
  
  // Sort by radius for better visual
  circles.sort((a, b) => b.radius - a.radius);
  animate();
}

// ═══════════════════════════════════════════════════════
// MESH GRADIENT
// ═══════════════════════════════════════════════════════

function drawMesh() {
  const points = [];
  const numPoints = 6;
  
  for (let i = 0; i < numPoints; i++) {
    points.push({
      x: random(0, width),
      y: random(0, height),
      vx: random(-1, 1),
      vy: random(-1, 1),
      color: palette[i % palette.length]
    });
  }
  
  function animate() {
    // Move points
    points.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      
      if (p.x < 0 || p.x > width) p.vx *= -1;
      if (p.y < 0 || p.y > height) p.vy *= -1;
    });
    
    // Draw gradient mesh
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    
    for (let y = 0; y < height; y += 2) {
      for (let x = 0; x < width; x += 2) {
        let r = 0, g = 0, b = 0, totalWeight = 0;
        
        points.forEach(p => {
          const dist = Math.hypot(x - p.x, y - p.y);
          const weight = 1 / (1 + dist * 0.01);
          totalWeight += weight;
          
          const color = p.color;
          r += parseInt(color.slice(1, 3), 16) * weight;
          g += parseInt(color.slice(3, 5), 16) * weight;
          b += parseInt(color.slice(5, 7), 16) * weight;
        });
        
        r = Math.floor(r / totalWeight);
        g = Math.floor(g / totalWeight);
        b = Math.floor(b / totalWeight);
        
        // Fill 2x2 block
        for (let dy = 0; dy < 2; dy++) {
          for (let dx = 0; dx < 2; dx++) {
            const i = ((y + dy) * width + (x + dx)) * 4;
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
            data[i + 3] = 255;
          }
        }
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    animationId = requestAnimationFrame(animate);
  }
  
  animate();
}

// ═══════════════════════════════════════════════════════
// WAVE INTERFERENCE
// ═══════════════════════════════════════════════════════

function drawWaves() {
  const sources = [];
  const numSources = Math.floor(random(3, 7));
  
  for (let i = 0; i < numSources; i++) {
    sources.push({
      x: random(0, width),
      y: random(0, height),
      freq: random(0.02, 0.05),
      phase: random(0, Math.PI * 2),
      color: palette[i % palette.length]
    });
  }
  
  let time = 0;
  
  function animate() {
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    
    for (let y = 0; y < height; y += 2) {
      for (let x = 0; x < width; x += 2) {
        let value = 0;
        
        sources.forEach(s => {
          const dist = Math.hypot(x - s.x, y - s.y);
          value += Math.sin(dist * s.freq - time + s.phase);
        });
        
        value = (value / sources.length + 1) / 2;
        
        const colorIndex = Math.floor(value * (palette.length - 1));
        const color = palette[colorIndex];
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        for (let dy = 0; dy < 2; dy++) {
          for (let dx = 0; dx < 2; dx++) {
            const i = ((y + dy) * width + (x + dx)) * 4;
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
            data[i + 3] = 255;
          }
        }
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    time += 0.05;
    animationId = requestAnimationFrame(animate);
  }
  
  animate();
}

// ═══════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════

function generate() {
  cancelAnimationFrame(animationId);
  choosePalette();
  document.getElementById('seed').textContent = `seed: ${seed}`;
  
  switch (currentMode) {
    case 'flow': drawFlowField(); break;
    case 'circles': drawCircles(); break;
    case 'mesh': drawMesh(); break;
    case 'waves': drawWaves(); break;
  }
}

// Controls
document.querySelectorAll('.control-btn[data-mode]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.control-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentMode = btn.dataset.mode;
    seed = Math.random() * 10000 | 0;
    generate();
  });
});

document.getElementById('regenerate').addEventListener('click', () => {
  seed = Math.random() * 10000 | 0;
  generate();
});

// Start
generate();
</script>
</body>
</html>
