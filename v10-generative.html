<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Web and Circuits LLC — Generative</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #000;
  min-height: 100vh;
  font-family: 'DM Sans', sans-serif;
  color: white;
  overflow: hidden;
}

#canvas {
  position: fixed;
  inset: 0;
  z-index: 0;
}

.content {
  position: relative;
  z-index: 10;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
}

h1 {
  font-size: clamp(48px, 10vw, 120px);
  font-weight: 700;
  letter-spacing: -0.04em;
  mix-blend-mode: difference;
  margin-bottom: 16px;
}

.tagline {
  font-size: clamp(14px, 2vw, 20px);
  opacity: 0.7;
  margin-bottom: 48px;
  mix-blend-mode: difference;
}

.buttons {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn {
  padding: 16px 32px;
  font-family: inherit;
  font-size: 14px;
  font-weight: 500;
  text-decoration: none;
  border-radius: 100px;
  transition: all 0.3s;
  cursor: pointer;
  mix-blend-mode: difference;
}

.btn-primary {
  background: white;
  color: black;
  border: none;
}

.btn-primary:hover {
  transform: scale(1.05);
}

.btn-outline {
  background: transparent;
  color: white;
  border: 1px solid rgba(255,255,255,0.3);
}

.btn-outline:hover {
  border-color: white;
  background: rgba(255,255,255,0.1);
}

/* Controls */
.controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 12px;
  z-index: 100;
  background: rgba(0,0,0,0.5);
  padding: 12px 20px;
  border-radius: 100px;
  backdrop-filter: blur(10px);
}

.control-btn {
  background: transparent;
  border: 1px solid rgba(255,255,255,0.3);
  color: white;
  padding: 8px 16px;
  font-family: inherit;
  font-size: 12px;
  border-radius: 100px;
  cursor: pointer;
  transition: all 0.2s;
}

.control-btn:hover {
  background: rgba(255,255,255,0.1);
  border-color: white;
}

.control-btn.active {
  background: white;
  color: black;
}

/* Seed display */
.seed-display {
  position: fixed;
  top: 20px;
  left: 20px;
  font-size: 11px;
  font-family: monospace;
  opacity: 0.4;
  z-index: 100;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="content">
  <img src="logo.svg" id="gen-logo" alt="Web and Circuits" style="width:160px;height:160px;filter:brightness(0) invert(1);margin-bottom:20px;mix-blend-mode:difference;">
  <h1>Web and Circuits LLC</h1>
  <p class="tagline"><span style="color:#4ecdc4">Make</span> the best of things. Have <span style="color:#4ecdc4">your fun</span>. Reload for a new one.</p>
  
  <div class="buttons">
    <a href="/lab/" class="btn btn-primary">See Our Work</a>
    <a href="#" class="btn btn-outline" onclick="document.getElementById('contact-modal').classList.add('open');return false">?</a>
  </div>
</div>

<div class="controls">
  <button class="control-btn active" data-mode="flow">Flow Field</button>
  <button class="control-btn" data-mode="circles">Circles</button>
  <button class="control-btn" data-mode="mesh">Mesh</button>
  <button class="control-btn" data-mode="waves">Waves</button>
  <button class="control-btn" id="regenerate">↻ New</button>
</div>

<div class="seed-display" id="seed">seed: </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let seed = Math.random() * 10000 | 0;
let currentMode = 'flow';
let animationId;

// Seeded random
function seededRandom() {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280;
}

function random(min = 0, max = 1) {
  return min + seededRandom() * (max - min);
}

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}

resize();
window.addEventListener('resize', () => {
  resize();
  generate();
});

// Color palettes
const palettes = [
  ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'],
  ['#a8e6cf', '#dcedc1', '#ffd3b6', '#ffaaa5', '#ff8b94'],
  ['#2d3436', '#636e72', '#b2bec3', '#dfe6e9', '#74b9ff'],
  ['#6c5ce7', '#a29bfe', '#fd79a8', '#f8a5c2', '#f5cd79'],
  ['#00b894', '#00cec9', '#0984e3', '#6c5ce7', '#e84393'],
  ['#1a1a2e', '#16213e', '#0f3460', '#e94560', '#533483'],
];

let palette;

function choosePalette() {
  const index = Math.floor(random(0, palettes.length));
  palette = palettes[index];
}

// ═══════════════════════════════════════════════════════
// FLOW FIELD
// ═══════════════════════════════════════════════════════

function drawFlowField() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  const scale = random(0.002, 0.008);
  const particles = [];
  const numParticles = 2000;
  
  for (let i = 0; i < numParticles; i++) {
    particles.push({
      x: random(0, width),
      y: random(0, height),
      vx: 0,
      vy: 0,
      color: palette[Math.floor(random(0, palette.length))],
      life: random(50, 200)
    });
  }
  
  function noise(x, y) {
    return Math.sin(x * scale * 3) * Math.cos(y * scale * 2) + 
           Math.sin(x * scale + y * scale) * 0.5;
  }
  
  function animate() {
    ctx.fillStyle = 'rgba(10, 10, 10, 0.02)';
    ctx.fillRect(0, 0, width, height);
    
    particles.forEach(p => {
      const angle = noise(p.x, p.y) * Math.PI * 4;
      p.vx = Math.cos(angle) * 2;
      p.vy = Math.sin(angle) * 2;
      
      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      
      if (p.life <= 0 || p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
        p.x = random(0, width);
        p.y = random(0, height);
        p.life = random(50, 200);
      }
      
      ctx.beginPath();
      ctx.arc(p.x, p.y, 1, 0, Math.PI * 2);
      ctx.fillStyle = p.color + '80';
      ctx.fill();
    });
    
    animationId = requestAnimationFrame(animate);
  }
  
  animate();
}

// ═══════════════════════════════════════════════════════
// PACKING CIRCLES
// ═══════════════════════════════════════════════════════

function drawCircles() {
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, width, height);
  
  const circles = [];
  const maxAttempts = 5000;
  const minRadius = 5;
  const maxRadius = 100;
  
  for (let i = 0; i < maxAttempts; i++) {
    const x = random(0, width);
    const y = random(0, height);
    let radius = maxRadius;
    
    // Find max radius that doesn't overlap
    for (const c of circles) {
      const dist = Math.hypot(x - c.x, y - c.y);
      const maxR = dist - c.radius - 2;
      if (maxR < radius) radius = maxR;
    }
    
    // Check edges
    radius = Math.min(radius, x, y, width - x, height - y);
    
    if (radius >= minRadius) {
      circles.push({ x, y, radius, color: palette[Math.floor(random(0, palette.length))] });
    }
  }
  
  // Animate circles appearing
  let drawn = 0;
  
  function animate() {
    if (drawn >= circles.length) {
      animationId = requestAnimationFrame(animate);
      return;
    }
    
    const batchSize = Math.ceil(circles.length / 60);
    for (let i = 0; i < batchSize && drawn < circles.length; i++, drawn++) {
      const c = circles[drawn];
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
      ctx.strokeStyle = c.color;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    animationId = requestAnimationFrame(animate);
  }
  
  // Sort by radius for better visual
  circles.sort((a, b) => b.radius - a.radius);
  animate();
}

// ═══════════════════════════════════════════════════════
// MESH GRADIENT
// ═══════════════════════════════════════════════════════

function drawMesh() {
  const points = [];
  const numPoints = 6;
  
  for (let i = 0; i < numPoints; i++) {
    points.push({
      x: random(0, width),
      y: random(0, height),
      vx: random(-1, 1),
      vy: random(-1, 1),
      color: palette[i % palette.length]
    });
  }
  
  function animate() {
    // Move points
    points.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      
      if (p.x < 0 || p.x > width) p.vx *= -1;
      if (p.y < 0 || p.y > height) p.vy *= -1;
    });
    
    // Draw gradient mesh
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    
    for (let y = 0; y < height; y += 2) {
      for (let x = 0; x < width; x += 2) {
        let r = 0, g = 0, b = 0, totalWeight = 0;
        
        points.forEach(p => {
          const dist = Math.hypot(x - p.x, y - p.y);
          const weight = 1 / (1 + dist * 0.01);
          totalWeight += weight;
          
          const color = p.color;
          r += parseInt(color.slice(1, 3), 16) * weight;
          g += parseInt(color.slice(3, 5), 16) * weight;
          b += parseInt(color.slice(5, 7), 16) * weight;
        });
        
        r = Math.floor(r / totalWeight);
        g = Math.floor(g / totalWeight);
        b = Math.floor(b / totalWeight);
        
        // Fill 2x2 block
        for (let dy = 0; dy < 2; dy++) {
          for (let dx = 0; dx < 2; dx++) {
            const i = ((y + dy) * width + (x + dx)) * 4;
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
            data[i + 3] = 255;
          }
        }
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    animationId = requestAnimationFrame(animate);
  }
  
  animate();
}

// ═══════════════════════════════════════════════════════
// WAVE INTERFERENCE
// ═══════════════════════════════════════════════════════

function drawWaves() {
  const sources = [];
  const numSources = Math.floor(random(3, 7));
  
  for (let i = 0; i < numSources; i++) {
    sources.push({
      x: random(0, width),
      y: random(0, height),
      freq: random(0.02, 0.05),
      phase: random(0, Math.PI * 2),
      color: palette[i % palette.length]
    });
  }
  
  let time = 0;
  
  function animate() {
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    
    for (let y = 0; y < height; y += 2) {
      for (let x = 0; x < width; x += 2) {
        let value = 0;
        
        sources.forEach(s => {
          const dist = Math.hypot(x - s.x, y - s.y);
          value += Math.sin(dist * s.freq - time + s.phase);
        });
        
        value = (value / sources.length + 1) / 2;
        
        const colorIndex = Math.floor(value * (palette.length - 1));
        const color = palette[colorIndex];
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        for (let dy = 0; dy < 2; dy++) {
          for (let dx = 0; dx < 2; dx++) {
            const i = ((y + dy) * width + (x + dx)) * 4;
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
            data[i + 3] = 255;
          }
        }
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    time += 0.05;
    animationId = requestAnimationFrame(animate);
  }
  
  animate();
}

// ═══════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════

function generate() {
  cancelAnimationFrame(animationId);
  choosePalette();
  document.getElementById('seed').textContent = `seed: ${seed}`;
  
  switch (currentMode) {
    case 'flow': drawFlowField(); break;
    case 'circles': drawCircles(); break;
    case 'mesh': drawMesh(); break;
    case 'waves': drawWaves(); break;
  }
}

// Controls
document.querySelectorAll('.control-btn[data-mode]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.control-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentMode = btn.dataset.mode;
    seed = Math.random() * 10000 | 0;
    generate();
  });
});

document.getElementById('regenerate').addEventListener('click', () => {
  seed = Math.random() * 10000 | 0;
  generate();
});

// Start
generate();
</script>
<!-- Contact Modal -->
<div id="contact-modal" class="gen-modal" onclick="if(event.target===this)this.classList.remove('open')">
  <div class="gen-modal-card">
    <canvas class="gen-modal-canvas" id="modal-canvas"></canvas>
    <button class="gen-modal-close" onclick="this.parentElement.parentElement.classList.remove('open')">&times;</button>
    <h2>New Connection</h2>
    <p>Small team building software, demos, and AI/ML experiments. Every project is a new seed.</p>
    <a href="mailto:hello@webandcircuits.com" class="btn btn-primary" style="margin-top:24px;display:inline-block;position:relative;z-index:1">hello@webandcircuits.com</a>
  </div>
</div>
<style>
.gen-modal{position:fixed;inset:0;z-index:9999;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.8);opacity:0;pointer-events:none;transition:opacity 0.4s}
.gen-modal.open{opacity:1;pointer-events:all}
.gen-modal-card{position:relative;background:#0a0a0a;border:1px solid rgba(255,255,255,0.15);border-radius:16px;padding:48px;max-width:440px;text-align:center;color:#fff;overflow:hidden;transform:scale(0.9);transition:transform 0.4s cubic-bezier(.175,.885,.32,1.275)}
.gen-modal.open .gen-modal-card{transform:scale(1)}
.gen-modal-card h2{font-size:28px;margin-bottom:16px;position:relative;z-index:1;mix-blend-mode:difference}
.gen-modal-card p{color:rgba(255,255,255,0.7);line-height:1.7;font-size:15px;position:relative;z-index:1;mix-blend-mode:difference}
.gen-modal-canvas{position:absolute;inset:0;width:100%;height:100%;opacity:0.4;pointer-events:none}
.gen-modal-close{position:absolute;top:14px;right:14px;background:none;border:none;color:rgba(255,255,255,0.4);font-size:24px;cursor:pointer;z-index:2}
.gen-modal-close:hover{color:#fff}
</style>
<script>
(function(){
  const mc=document.getElementById('modal-canvas');
  const mctx=mc.getContext('2d');
  function resizeMC(){mc.width=mc.parentElement.offsetWidth;mc.height=mc.parentElement.offsetHeight}
  const obs=new MutationObserver(()=>{if(document.getElementById('contact-modal').classList.contains('open')){resizeMC();drawModalParticles()}});
  obs.observe(document.getElementById('contact-modal'),{attributes:true});
  function drawModalParticles(){
    const w=mc.width,h=mc.height;mctx.clearRect(0,0,w,h);
    const colors=['#ff6b6b','#4ecdc4','#45b7d1','#a29bfe','#fd79a8'];
    for(let i=0;i<60;i++){
      const x=Math.random()*w,y=Math.random()*h,r=Math.random()*3+1;
      mctx.beginPath();mctx.arc(x,y,r,0,Math.PI*2);
      mctx.fillStyle=colors[Math.floor(Math.random()*colors.length)];mctx.fill();
    }
    for(let i=0;i<20;i++){
      const x1=Math.random()*w,y1=Math.random()*h,x2=Math.random()*w,y2=Math.random()*h;
      mctx.beginPath();mctx.moveTo(x1,y1);mctx.lineTo(x2,y2);
      mctx.strokeStyle='rgba(255,255,255,0.08)';mctx.stroke();
    }
  }
})();
</script>
<script>document.addEventListener("keydown",e=>{if(e.key==="Escape")document.getElementById("contact-modal").classList.remove("open")})</script>
</body>
</html>
