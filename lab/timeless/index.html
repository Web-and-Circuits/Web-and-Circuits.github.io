<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Timeless Way ‚Äî An Interactive Experience</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0a0a0f;
  --surface: #12121a;
  --surface2: #1a1a25;
  --text: #e8e4df;
  --text-dim: #8a857e;
  --accent: #c4956a;
  --accent2: #7a9e7e;
  --alive: #8aba8e;
  --dead: #ba6a6a;
  --gold: #d4a55a;
}

html { scroll-behavior: smooth; }

body {
  font-family: 'Georgia', 'Times New Roman', serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.7;
  overflow-x: hidden;
}

/* ===== HERO ===== */
.hero {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  padding: 2rem;
  position: relative;
  overflow: hidden;
}

.hero-bg {
  position: absolute;
  inset: 0;
  z-index: 0;
}

.hero-bg canvas { width: 100%; height: 100%; }

.hero-content { position: relative; z-index: 1; max-width: 700px; }

.hero h1 {
  font-size: clamp(2rem, 6vw, 3.5rem);
  font-weight: 400;
  letter-spacing: 0.05em;
  margin-bottom: 0.5em;
  color: var(--text);
}

.hero h1 em {
  font-style: italic;
  color: var(--accent);
}

.hero .subtitle {
  font-size: clamp(1rem, 2.5vw, 1.3rem);
  color: var(--text-dim);
  margin-bottom: 2em;
  font-style: italic;
}

.hero .cta {
  display: inline-block;
  padding: 14px 36px;
  border: 1px solid var(--accent);
  color: var(--accent);
  text-decoration: none;
  font-size: 1rem;
  letter-spacing: 0.1em;
  transition: all 0.3s;
  min-height: 48px;
  cursor: pointer;
  background: transparent;
  font-family: inherit;
}

.hero .cta:hover { background: var(--accent); color: var(--bg); }

/* ===== SECTIONS ===== */
section {
  max-width: 800px;
  margin: 0 auto;
  padding: 5rem 1.5rem;
}

.section-number {
  font-size: 0.8rem;
  letter-spacing: 0.3em;
  color: var(--accent);
  text-transform: uppercase;
  margin-bottom: 0.5rem;
}

section h2 {
  font-size: clamp(1.5rem, 4vw, 2.2rem);
  font-weight: 400;
  margin-bottom: 1rem;
  line-height: 1.3;
}

.quote-block {
  border-left: 2px solid var(--accent);
  padding: 1rem 1.5rem;
  margin: 2rem 0;
  color: var(--text-dim);
  font-style: italic;
  font-size: 0.95rem;
}

.quote-block cite {
  display: block;
  margin-top: 0.5rem;
  font-size: 0.8rem;
  color: var(--accent);
  font-style: normal;
}

p + p { margin-top: 1rem; }

.instruction {
  background: var(--surface);
  border: 1px solid #2a2a35;
  border-radius: 8px;
  padding: 1.2rem 1.5rem;
  margin: 1.5rem 0;
  font-size: 0.9rem;
  color: var(--accent);
  text-align: center;
}

/* ===== INTERACTIVE: ALIVE vs DEAD ROOMS ===== */
.room-compare {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.5rem;
  margin: 2rem 0;
}

@media (max-width: 600px) {
  .room-compare { grid-template-columns: 1fr; }
}

.room-box {
  position: relative;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  min-height: 280px;
  transition: transform 0.3s, box-shadow 0.3s;
  display: flex;
  flex-direction: column;
}

.room-box:hover { transform: translateY(-2px); }
.room-box:active { transform: scale(0.98); }

.room-canvas {
  flex: 1;
  min-height: 200px;
}

.room-label {
  padding: 12px 16px;
  font-size: 0.85rem;
  text-align: center;
  min-height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.room-box.alive { border: 1px solid var(--alive); }
.room-box.alive .room-label { background: rgba(138,186,142,0.1); color: var(--alive); }

.room-box.dead { border: 1px solid var(--dead); }
.room-box.dead .room-label { background: rgba(186,106,106,0.1); color: var(--dead); }

.room-feedback {
  text-align: center;
  margin-top: 1rem;
  min-height: 3rem;
  font-style: italic;
  color: var(--text-dim);
  transition: opacity 0.4s;
}

/* ===== INTERACTIVE: PATTERN BUILDER ===== */
.pattern-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 0.8rem;
  margin: 1.5rem 0;
}

.pattern-chip {
  padding: 12px 16px;
  background: var(--surface);
  border: 1px solid #2a2a35;
  border-radius: 6px;
  cursor: pointer;
  text-align: center;
  font-size: 0.85rem;
  transition: all 0.3s;
  min-height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
}

.pattern-chip:hover { border-color: var(--accent); }
.pattern-chip.selected { background: rgba(196,149,106,0.15); border-color: var(--accent); color: var(--accent); }

.language-preview {
  margin-top: 2rem;
  background: var(--surface);
  border-radius: 8px;
  padding: 1.5rem;
  min-height: 200px;
  border: 1px solid #2a2a35;
  position: relative;
}

.language-preview canvas {
  width: 100%;
  height: 300px;
  display: block;
}

.aliveness-meter {
  margin-top: 1rem;
  display: flex;
  align-items: center;
  gap: 1rem;
}

.meter-bar {
  flex: 1;
  height: 6px;
  background: var(--surface2);
  border-radius: 3px;
  overflow: hidden;
}

.meter-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.6s ease, background 0.6s;
  width: 0%;
}

.meter-label {
  font-size: 0.8rem;
  color: var(--text-dim);
  min-width: 80px;
  text-align: right;
}

/* ===== INTERACTIVE: FORCES SLIDER ===== */
.forces-demo {
  margin: 2rem 0;
  background: var(--surface);
  border-radius: 8px;
  padding: 2rem;
  border: 1px solid #2a2a35;
}

.forces-visual {
  width: 100%;
  height: 250px;
  margin-bottom: 1.5rem;
}

.slider-row {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
}

.slider-row label {
  font-size: 0.85rem;
  color: var(--text-dim);
  min-width: 100px;
}

.slider-row input[type="range"] {
  flex: 1;
  height: 44px;
  -webkit-appearance: none;
  background: transparent;
  cursor: pointer;
}

.slider-row input[type="range"]::-webkit-slider-runnable-track {
  height: 4px;
  background: var(--surface2);
  border-radius: 2px;
}

.slider-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  margin-top: -8px;
}

.forces-text {
  font-size: 0.9rem;
  color: var(--text-dim);
  font-style: italic;
  text-align: center;
  min-height: 2rem;
}

/* ===== INTERACTIVE: NAMING THE UNNAMED ===== */
.word-cloud {
  display: flex;
  flex-wrap: wrap;
  gap: 0.8rem;
  justify-content: center;
  margin: 2rem 0;
}

.word-orb {
  padding: 14px 24px;
  border-radius: 30px;
  border: 1px solid #2a2a35;
  cursor: pointer;
  font-size: 0.95rem;
  transition: all 0.5s;
  min-height: 48px;
  display: flex;
  align-items: center;
  background: var(--surface);
  user-select: none;
}

.word-orb:hover { border-color: var(--gold); }

.word-orb.touched {
  border-color: var(--gold);
  background: rgba(212,165,90,0.08);
  color: var(--gold);
}

.word-orb.fading {
  opacity: 0.3;
  border-color: #1a1a25;
}

#naming-revelation {
  text-align: center;
  margin-top: 2rem;
  font-size: 1.1rem;
  min-height: 4rem;
  color: var(--gold);
  transition: opacity 0.6s;
  opacity: 0;
}

#naming-revelation.visible { opacity: 1; }

/* ===== INTERACTIVE: DIFFERENTIATION ===== */
.diff-demo {
  margin: 2rem 0;
}

.diff-controls {
  display: flex;
  gap: 1rem;
  justify-content: center;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

.diff-btn {
  padding: 12px 24px;
  background: var(--surface);
  border: 1px solid #2a2a35;
  color: var(--text);
  cursor: pointer;
  border-radius: 6px;
  font-family: inherit;
  font-size: 0.85rem;
  transition: all 0.3s;
  min-height: 48px;
}

.diff-btn:hover { border-color: var(--accent2); }
.diff-btn.active { background: rgba(122,158,126,0.15); border-color: var(--accent2); color: var(--accent2); }

.diff-canvas {
  width: 100%;
  height: 350px;
  background: var(--surface);
  border-radius: 8px;
  border: 1px solid #2a2a35;
}

/* ===== INTERACTIVE: REPAIR TIMELINE ===== */
.repair-timeline {
  margin: 2rem 0;
  position: relative;
}

.repair-canvas {
  width: 100%;
  height: 300px;
  background: var(--surface);
  border-radius: 8px;
  border: 1px solid #2a2a35;
  margin-bottom: 1rem;
}

.repair-slider {
  width: 100%;
  height: 44px;
  -webkit-appearance: none;
  background: transparent;
  cursor: pointer;
}

.repair-slider::-webkit-slider-runnable-track {
  height: 4px;
  background: var(--surface2);
  border-radius: 2px;
}

.repair-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--accent2);
  margin-top: -10px;
}

.repair-year {
  text-align: center;
  font-size: 0.9rem;
  color: var(--text-dim);
}

/* ===== INTERACTIVE: FISH POND ===== */
.pond-container {
  margin: 2rem 0;
  position: relative;
  width: 100%;
  max-width: 500px;
  margin-left: auto;
  margin-right: auto;
}

.pond-canvas {
  width: 100%;
  height: 400px;
  background: var(--surface);
  border-radius: 8px;
  border: 1px solid #2a2a35;
  cursor: pointer;
}

.pond-text {
  text-align: center;
  font-size: 0.85rem;
  color: var(--text-dim);
  margin-top: 0.5rem;
  font-style: italic;
}

/* ===== FOOTER ===== */
.footer {
  text-align: center;
  padding: 4rem 2rem;
  color: var(--text-dim);
  font-size: 0.85rem;
  max-width: 600px;
  margin: 0 auto;
}

.footer p + p { margin-top: 0.5rem; }

/* ===== NAV DOTS ===== */
.nav-dots {
  position: fixed;
  right: 1rem;
  top: 50%;
  transform: translateY(-50%);
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

@media (max-width: 600px) { .nav-dots { display: none; } }

.nav-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--surface2);
  border: 1px solid #3a3a45;
  cursor: pointer;
  transition: all 0.3s;
  min-width: 8px;
  min-height: 8px;
}

.nav-dot.active { background: var(--accent); border-color: var(--accent); transform: scale(1.3); }

/* ===== SCROLL ANIMATIONS ===== */
.fade-in {
  opacity: 0;
  transform: translateY(30px);
  transition: opacity 0.8s ease, transform 0.8s ease;
}

.fade-in.visible {
  opacity: 1;
  transform: translateY(0);
}

/* Divider */
.section-divider {
  width: 60px;
  height: 1px;
  background: var(--accent);
  margin: 0 auto 3rem;
  opacity: 0.4;
}
</style>
</head>
<body>

<!-- Navigation Dots -->
<nav class="nav-dots" id="navDots"></nav>

<!-- ===== HERO ===== -->
<div class="hero" id="sec-hero">
  <div class="hero-bg"><canvas id="heroCanvas"></canvas></div>
  <div class="hero-content fade-in">
    <h1>The <em>Timeless</em> Way</h1>
    <p class="subtitle">An interactive exploration of Christopher Alexander's<br>theory of living buildings</p>
    <button class="cta" onclick="document.getElementById('sec-1').scrollIntoView({behavior:'smooth'})">Begin the journey</button>
  </div>
</div>

<!-- ===== 1. THE QUALITY WITHOUT A NAME ===== -->
<section id="sec-1">
  <div class="fade-in">
    <p class="section-number">I</p>
    <h2>The Quality Without a Name</h2>
    <div class="quote-block">
      "There is a central quality which is the root criterion of life and spirit in a man, a town, a building, or a wilderness. This quality is objective and precise, but it cannot be named."
      <cite>‚Äî Chapter 2</cite>
    </div>
    <p>Alexander argues that the most important quality in any place ‚Äî the thing that makes it feel <em>alive</em> ‚Äî cannot be captured by any single word. Each word circles the truth but misses.</p>
    <p class="instruction">Touch each word below. Watch how it illuminates the quality ‚Äî and how it falls short.</p>
  </div>

  <div class="word-cloud fade-in" id="wordCloud">
    <div class="word-orb" data-word="alive" data-desc="It lives ‚Äî but 'alive' is a metaphor. A fire can be alive. What does it really mean?">Alive</div>
    <div class="word-orb" data-word="whole" data-desc="Free of inner contradictions ‚Äî but 'whole' sounds closed, self-contained. Life is never sealed off.">Whole</div>
    <div class="word-orb" data-word="comfortable" data-desc="Deeply at ease ‚Äî not the dull comfort of luxury, but the profound rightness of a thing perfectly placed.">Comfortable</div>
    <div class="word-orb" data-word="free" data-desc="Wild, abandoned, unforced ‚Äî but freedom can be theatrical, a pose. That's the opposite of this quality.">Free</div>
    <div class="word-orb" data-word="exact" data-desc="Perfectly adapted to every force ‚Äî but 'exact' sounds rigid. This exactness requires looseness.">Exact</div>
    <div class="word-orb" data-word="egoless" data-desc="No maker's will imposed ‚Äî but not selfless. The maker's person is in it; only the ego is gone.">Egoless</div>
    <div class="word-orb" data-word="eternal" data-desc="It touches something timeless ‚Äî but 'eternal' sounds mystical. This quality is profoundly ordinary.">Eternal</div>
  </div>
  <div id="naming-revelation"></div>
</section>

<div class="section-divider"></div>

<!-- ===== 2. ALIVE vs DEAD PATTERNS ===== -->
<section id="sec-2">
  <div class="fade-in">
    <p class="section-number">II</p>
    <h2>Patterns Alive & Dead</h2>
    <div class="quote-block">
      "The specific patterns out of which a building or a town is made may be alive or dead. To the extent they are alive, they let our inner forces loose, and set us free; but when they are dead, they keep us locked in inner conflict."
      <cite>‚Äî Chapter 6</cite>
    </div>
    <p>Alexander's key insight: a room with a <em>window place</em> ‚Äî a seat, bay, or alcove by the window ‚Äî resolves two forces pulling at you: the draw toward light, and the need to sit comfortably. Without it, these forces stay in permanent conflict.</p>
    <p class="instruction">Click each room to feel the difference.</p>
  </div>

  <div class="room-compare fade-in">
    <div class="room-box alive" id="roomAlive" onclick="clickRoom('alive')">
      <canvas class="room-canvas" id="canvasAlive"></canvas>
      <div class="room-label">A room with a window place</div>
    </div>
    <div class="room-box dead" id="roomDead" onclick="clickRoom('dead')">
      <canvas class="room-canvas" id="canvasDead"></canvas>
      <div class="room-label">A room with holes in the wall</div>
    </div>
  </div>
  <div class="room-feedback fade-in" id="roomFeedback"></div>
</section>

<div class="section-divider"></div>

<!-- ===== 3. FEELING THE FORCES ===== -->
<section id="sec-3">
  <div class="fade-in">
    <p class="section-number">III</p>
    <h2>Feeling the Forces</h2>
    <div class="quote-block">
      "A pattern lives when it allows its own internal forces to resolve themselves. And a pattern dies when it fails to provide a framework in which forces can resolve themselves."
      <cite>‚Äî Chapter 6</cite>
    </div>
    <p>Every pattern exists within a field of forces. A courtyard has forces pulling you outside (sunlight, air, nature) and forces pushing you back (exposure, enclosure, unfamiliarity). When the pattern resolves these forces ‚Äî with a view out, crossing paths, a transitional porch ‚Äî the courtyard comes alive.</p>
    <p class="instruction">Adjust the sliders to balance the forces. Watch the courtyard breathe ‚Äî or suffocate.</p>
  </div>

  <div class="forces-demo fade-in">
    <canvas class="forces-visual" id="forcesCanvas"></canvas>
    <div class="slider-row">
      <label>Openness</label>
      <input type="range" min="0" max="100" value="20" id="sliderOpen" oninput="updateForces()">
    </div>
    <div class="slider-row">
      <label>Crossing paths</label>
      <input type="range" min="0" max="100" value="10" id="sliderPaths" oninput="updateForces()">
    </div>
    <div class="slider-row">
      <label>Transition</label>
      <input type="range" min="0" max="100" value="10" id="sliderTransition" oninput="updateForces()">
    </div>
    <div class="forces-text" id="forcesText">The courtyard is enclosed and dead. No one wants to be here.</div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ===== 4. PATTERN LANGUAGE ===== -->
<section id="sec-4">
  <div class="fade-in">
    <p class="section-number">IV</p>
    <h2>Building a Pattern Language</h2>
    <div class="quote-block">
      "A pattern language gives each person who uses it the power to create an infinite variety of new and unique buildings, just as his ordinary language gives him the power to create an infinite variety of sentences."
      <cite>‚Äî Chapter 10</cite>
    </div>
    <p>A pattern language is not a blueprint. It's a system of interconnected rules ‚Äî like words in a language ‚Äî that generates infinite variety. Select patterns below and watch a building emerge from their combination.</p>
    <p class="instruction">Choose patterns to compose your building. Each combination generates a different place.</p>
  </div>

  <div class="pattern-grid fade-in" id="patternGrid">
    <div class="pattern-chip" data-pat="sunny-place" onclick="togglePattern(this)">‚òÄÔ∏è Sunny Place</div>
    <div class="pattern-chip" data-pat="entrance" onclick="togglePattern(this)">üö™ Entrance Transition</div>
    <div class="pattern-chip" data-pat="window-place" onclick="togglePattern(this)">ü™ü Window Place</div>
    <div class="pattern-chip" data-pat="courtyard" onclick="togglePattern(this)">üèõÔ∏è Courtyard</div>
    <div class="pattern-chip" data-pat="alcove" onclick="togglePattern(this)">üõãÔ∏è Alcoves</div>
    <div class="pattern-chip" data-pat="garden" onclick="togglePattern(this)">üåø Garden Growing Wild</div>
    <div class="pattern-chip" data-pat="columns" onclick="togglePattern(this)">üèõÔ∏è Thick Columns</div>
    <div class="pattern-chip" data-pat="ceiling" onclick="togglePattern(this)">üìê Ceiling Heights</div>
    <div class="pattern-chip" data-pat="light" onclick="togglePattern(this)">üí° Light on Two Sides</div>
    <div class="pattern-chip" data-pat="roof" onclick="togglePattern(this)">üè† Sheltering Roof</div>
    <div class="pattern-chip" data-pat="edge" onclick="togglePattern(this)">ü™® Building Edge</div>
    <div class="pattern-chip" data-pat="ornament" onclick="togglePattern(this)">‚ú® Ornament</div>
  </div>

  <div class="language-preview fade-in">
    <canvas id="langCanvas"></canvas>
    <div class="aliveness-meter">
      <span class="meter-label">Aliveness</span>
      <div class="meter-bar"><div class="meter-fill" id="meterFill"></div></div>
    </div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ===== 5. DIFFERENTIATING SPACE ===== -->
<section id="sec-5">
  <div class="fade-in">
    <p class="section-number">V</p>
    <h2>Differentiating Space</h2>
    <div class="quote-block">
      "It is not a process of addition, in which preformed parts are combined to create a whole, but a process of unfolding, like the evolution of an embryo, in which the whole precedes the parts, and actually gives birth to them, by splitting."
      <cite>‚Äî Chapter 19</cite>
    </div>
    <p>Modern construction assembles prefabricated parts. The timeless way <em>differentiates</em> space ‚Äî like a cell dividing. The whole comes first; details emerge from it. Watch the difference.</p>
    <p class="instruction">Choose a process and watch how space takes form.</p>
  </div>

  <div class="diff-demo fade-in">
    <div class="diff-controls">
      <button class="diff-btn active" onclick="runDiff('organic')" id="btnOrganic">Differentiation (Organic)</button>
      <button class="diff-btn" onclick="runDiff('modular')" id="btnModular">Assembly (Modular)</button>
    </div>
    <canvas class="diff-canvas" id="diffCanvas"></canvas>
  </div>
</section>

<div class="section-divider"></div>

<!-- ===== 6. THE PROCESS OF REPAIR ===== -->
<section id="sec-6">
  <div class="fade-in">
    <p class="section-number">VI</p>
    <h2>The Process of Repair</h2>
    <div class="quote-block">
      "Several acts of building, each one done to repair and magnify the product of the previous acts, will slowly generate a larger and more complex whole than any single act can generate."
      <cite>‚Äî Chapter 24</cite>
    </div>
    <p>A living town is never finished. It grows through countless small acts of repair ‚Äî each one making the whole a little more alive. No master plan, no single vision. Just patient, continuous adaptation.</p>
    <p class="instruction">Drag the slider through time and watch a place grow.</p>
  </div>

  <div class="repair-timeline fade-in">
    <canvas class="repair-canvas" id="repairCanvas"></canvas>
    <input type="range" class="repair-slider" min="0" max="100" value="0" id="repairSlider" oninput="updateRepair()">
    <div class="repair-year" id="repairYear">Year 1</div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ===== 7. THE FISH POND ===== -->
<section id="sec-7">
  <div class="fade-in">
    <p class="section-number">VII</p>
    <h2>The Eternal Pond</h2>
    <div class="quote-block">
      "I once saw a simple fish pond in a Japanese village which was perhaps eternal. ‚Ä¶ The whole world was in that pond. Every day the farmer sat by it for a few minutes. I was there only one day and I sat by it all afternoon. Even now, I cannot think of it without tears."
      <cite>‚Äî Chapter 2</cite>
    </div>
    <p>Alexander's most haunting image: a rectangular pond, 6 by 8 feet, fed by an irrigation stream. A bush of flowers at one end. A wooden circle underwater. Eight ancient carp, the oldest eighty years old, swimming slowly in circles.</p>
    <p>This is what it means for a pattern to be eternal ‚Äî not that it lasts forever, but that in this moment it is so true to its own nature that it touches something outside of time.</p>
    <p class="instruction">Sit with the pond. Watch the fish.</p>
  </div>

  <div class="pond-container fade-in">
    <canvas class="pond-canvas" id="pondCanvas"></canvas>
    <div class="pond-text">The eight fish swim, slowly, slowly, in circles.</div>
  </div>
</section>

<div class="section-divider"></div>

<!-- ===== FOOTER ===== -->
<div class="footer" id="sec-footer">
  <div class="fade-in">
    <p style="font-size:1.1rem; color: var(--accent); margin-bottom: 1rem;"><em>"The power to make buildings beautiful lies in each of us already."</em></p>
    <p>Based on <strong>The Timeless Way of Building</strong> by Christopher Alexander (1979)</p>
    <p style="margin-top: 2rem; font-size: 0.75rem;">An interactive exploration. No images, no frameworks ‚Äî just patterns in code,<br>like patterns in space.</p>
  </div>
</div>

<script>
// ===== UTILITY =====
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function rand(a, b) { return a + Math.random() * (b - a); }

// ===== SCROLL ANIMATIONS =====
const fadeEls = document.querySelectorAll('.fade-in');
const io = new IntersectionObserver((entries) => {
  entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
}, { threshold: 0.15 });
fadeEls.forEach(el => io.observe(el));

// ===== NAV DOTS =====
const sections = ['sec-hero','sec-1','sec-2','sec-3','sec-4','sec-5','sec-6','sec-7'];
const navDots = document.getElementById('navDots');
sections.forEach((id, i) => {
  const dot = document.createElement('div');
  dot.className = 'nav-dot';
  dot.onclick = () => document.getElementById(id).scrollIntoView({ behavior: 'smooth' });
  navDots.appendChild(dot);
});

function updateNav() {
  const dots = navDots.children;
  let active = 0;
  sections.forEach((id, i) => {
    const el = document.getElementById(id);
    if (el && el.getBoundingClientRect().top < window.innerHeight * 0.5) active = i;
  });
  Array.from(dots).forEach((d, i) => d.classList.toggle('active', i === active));
}
window.addEventListener('scroll', updateNav, { passive: true });
updateNav();

// ===== HERO CANVAS ‚Äî Gentle flowing particles =====
(function() {
  const c = document.getElementById('heroCanvas');
  const ctx = c.getContext('2d');
  let W, H;
  const particles = [];

  function resize() {
    W = c.width = c.offsetWidth * devicePixelRatio;
    H = c.height = c.offsetHeight * devicePixelRatio;
    ctx.scale(1, 1);
  }
  resize();
  window.addEventListener('resize', resize);

  for (let i = 0; i < 60; i++) {
    particles.push({
      x: rand(0, W), y: rand(0, H),
      vx: rand(-0.3, 0.3), vy: rand(-0.3, 0.3),
      r: rand(1, 3), a: rand(0.05, 0.2)
    });
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);
    particles.forEach(p => {
      p.x += p.vx; p.y += p.vy;
      if (p.x < 0) p.x = W; if (p.x > W) p.x = 0;
      if (p.y < 0) p.y = H; if (p.y > H) p.y = 0;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(196,149,106,${p.a})`;
      ctx.fill();
    });

    // Draw connections
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < 120) {
          ctx.beginPath();
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.strokeStyle = `rgba(196,149,106,${0.06 * (1 - d/120)})`;
          ctx.stroke();
        }
      }
    }
    requestAnimationFrame(draw);
  }
  draw();
})();

// ===== 1. NAMING THE UNNAMED =====
(function() {
  const orbs = document.querySelectorAll('.word-orb');
  const rev = document.getElementById('naming-revelation');
  let touched = 0;

  orbs.forEach(orb => {
    orb.addEventListener('click', () => {
      if (orb.classList.contains('touched')) return;
      orb.classList.add('touched');
      touched++;

      // Show description
      rev.textContent = orb.dataset.desc;
      rev.classList.add('visible');

      if (touched >= orbs.length) {
        setTimeout(() => {
          rev.innerHTML = '<em>"Each word is an ellipse‚Ä¶ No word can ever catch the quality without a name because the quality is too particular, and words too broad."</em>';
          orbs.forEach(o => o.classList.add('fading'));
        }, 2000);
      }
    });
  });
})();

// ===== 2. ALIVE vs DEAD ROOMS =====
function drawRoom(canvasId, alive) {
  const c = document.getElementById(canvasId);
  const ctx = c.getContext('2d');
  const dpr = devicePixelRatio;
  c.width = c.offsetWidth * dpr;
  c.height = c.offsetHeight * dpr;
  const W = c.width, H = c.height;

  ctx.fillStyle = '#0e0e16';
  ctx.fillRect(0, 0, W, H);

  const mx = W * 0.1, my = H * 0.1;
  const rw = W * 0.8, rh = H * 0.8;

  // Floor
  ctx.fillStyle = '#1a1a22';
  ctx.fillRect(mx, my, rw, rh);

  // Walls
  ctx.strokeStyle = '#3a3a45';
  ctx.lineWidth = 3;
  ctx.strokeRect(mx, my, rw, rh);

  if (alive) {
    // Window bay ‚Äî a protruding alcove with warm light
    const bx = mx + rw * 0.3, by = my, bw = rw * 0.4, bd = rh * 0.25;
    ctx.fillStyle = '#2a2520';
    ctx.fillRect(bx, by - bd, bw, bd + 4);
    ctx.strokeStyle = '#3a3a45';
    ctx.strokeRect(bx, by - bd, bw, bd + 4);

    // Window panes (small panes!)
    const panes = 3;
    const pw = bw / panes;
    for (let i = 0; i < panes; i++) {
      ctx.fillStyle = `rgba(180,160,120,${0.15 + i * 0.05})`;
      ctx.fillRect(bx + i * pw + 3, by - bd + 3, pw - 6, bd - 6);
      ctx.strokeStyle = '#4a4535';
      ctx.lineWidth = 1;
      ctx.strokeRect(bx + i * pw + 3, by - bd + 3, pw - 6, bd - 6);
    }

    // Window seat
    ctx.fillStyle = '#2a2822';
    ctx.fillRect(bx + 4, by - 12, bw - 8, 16);

    // Warm light glow
    const grad = ctx.createRadialGradient(bx + bw/2, by - bd/2, 10, bx + bw/2, by + rh * 0.3, rh * 0.6);
    grad.addColorStop(0, 'rgba(200,170,100,0.12)');
    grad.addColorStop(1, 'rgba(200,170,100,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(mx, my, rw, rh);

    // Cushion on window seat
    ctx.fillStyle = '#8a6a4a';
    ctx.beginPath();
    ctx.ellipse(bx + bw * 0.35, by - 4, 14, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#7a5a3a';
    ctx.beginPath();
    ctx.ellipse(bx + bw * 0.65, by - 4, 12, 7, 0.2, 0, Math.PI * 2);
    ctx.fill();

    // A small plant
    ctx.fillStyle = '#5a7a5a';
    ctx.beginPath();
    ctx.arc(bx + bw - 15, by - bd + 15, 8, 0, Math.PI * 2);
    ctx.fill();

    // Chair near window
    ctx.fillStyle = '#2a2822';
    ctx.fillRect(bx + bw/2 - 15, by + 20, 30, 30);
    ctx.fillStyle = '#3a3832';
    ctx.fillRect(bx + bw/2 - 12, by + 22, 24, 26);

  } else {
    // Dead: two identical rectangular windows ‚Äî just holes
    const wy = my + 4;
    const wh = rh * 0.2;
    const ww = rw * 0.25;

    for (let i = 0; i < 2; i++) {
      const wx = mx + rw * 0.15 + i * rw * 0.45;
      // Just a flat rectangle
      ctx.fillStyle = '#1a1a2a';
      ctx.fillRect(wx, wy, ww, wh);
      // Single pane
      ctx.fillStyle = 'rgba(140,150,180,0.08)';
      ctx.fillRect(wx + 2, wy + 2, ww - 4, wh - 4);
      ctx.strokeStyle = '#2a2a35';
      ctx.lineWidth = 1;
      ctx.strokeRect(wx, wy, ww, wh);
    }

    // Furniture far from windows ‚Äî uncomfortable tension
    ctx.fillStyle = '#1e1e28';
    ctx.fillRect(mx + rw * 0.35, my + rh * 0.55, rw * 0.3, rh * 0.2);
    ctx.fillStyle = '#252530';
    ctx.fillRect(mx + rw * 0.38, my + rh * 0.57, rw * 0.24, rh * 0.16);

    // Fluorescent light strip
    ctx.fillStyle = 'rgba(180,190,210,0.06)';
    ctx.fillRect(mx + rw * 0.2, my + rh * 0.02, rw * 0.6, 3);
  }
}

function clickRoom(type) {
  const fb = document.getElementById('roomFeedback');
  if (type === 'alive') {
    fb.innerHTML = '<span style="color:var(--alive)">You feel the pull toward the light, and you can follow it. The window seat invites you. The two forces ‚Äî light and comfort ‚Äî resolve.</span>';
  } else {
    fb.innerHTML = '<span style="color:var(--dead)">The light pulls you toward the wall, but there\'s nowhere to sit there. The comfortable chair is in the dark. You can never satisfy both forces at once.</span>';
  }
}

function initRooms() {
  drawRoom('canvasAlive', true);
  drawRoom('canvasDead', false);
}
window.addEventListener('resize', initRooms);
initRooms();

// ===== 3. FORCES COURTYARD =====
function updateForces() {
  const open = +document.getElementById('sliderOpen').value;
  const paths = +document.getElementById('sliderPaths').value;
  const trans = +document.getElementById('sliderTransition').value;

  const aliveness = (open + paths + trans) / 3;

  const c = document.getElementById('forcesCanvas');
  const ctx = c.getContext('2d');
  const dpr = devicePixelRatio;
  c.width = c.offsetWidth * dpr;
  c.height = c.offsetHeight * dpr;
  const W = c.width, H = c.height;

  ctx.fillStyle = '#0e0e16';
  ctx.fillRect(0, 0, W, H);

  const cx = W / 2, cy = H / 2;
  const s = Math.min(W, H) * 0.35;

  // Courtyard walls
  const wallAlpha = 1 - open / 150;
  ctx.strokeStyle = `rgba(100,95,85,${clamp(wallAlpha, 0.3, 1)})`;
  ctx.lineWidth = 4;

  // Four walls, but open on one side proportional to slider
  const gap = open / 100 * s * 0.8;
  // Top wall
  ctx.beginPath();
  ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx + s, cy - s);
  ctx.stroke();
  // Left wall
  ctx.beginPath();
  ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx - s, cy + s);
  ctx.stroke();
  // Right wall
  ctx.beginPath();
  ctx.moveTo(cx + s, cy - s); ctx.lineTo(cx + s, cy + s);
  ctx.stroke();
  // Bottom wall with gap (view out)
  ctx.beginPath();
  ctx.moveTo(cx - s, cy + s); ctx.lineTo(cx - gap/2, cy + s);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + gap/2, cy + s); ctx.lineTo(cx + s, cy + s);
  ctx.stroke();

  // View through gap ‚Äî landscape hint
  if (open > 30) {
    const vAlpha = (open - 30) / 100;
    ctx.fillStyle = `rgba(80,120,80,${vAlpha * 0.15})`;
    ctx.fillRect(cx - gap/2, cy + s, gap, H - (cy + s));
    // Small trees in distance
    ctx.fillStyle = `rgba(80,130,80,${vAlpha * 0.3})`;
    for (let i = 0; i < 3; i++) {
      const tx = cx - gap/3 + i * gap/3;
      ctx.beginPath();
      ctx.arc(tx, cy + s + 25, 8, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Crossing paths
  if (paths > 20) {
    const pAlpha = (paths - 20) / 80;
    ctx.strokeStyle = `rgba(180,160,120,${pAlpha * 0.4})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    // Path 1 ‚Äî horizontal
    ctx.beginPath();
    ctx.moveTo(cx - s + 10, cy);
    ctx.lineTo(cx + s - 10, cy);
    ctx.stroke();
    // Path 2 ‚Äî vertical
    ctx.beginPath();
    ctx.moveTo(cx, cy - s + 10);
    ctx.lineTo(cx, cy + s - 10);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Transition porch
  if (trans > 20) {
    const tAlpha = (trans - 20) / 80;
    // Porch along one wall
    ctx.fillStyle = `rgba(140,120,90,${tAlpha * 0.12})`;
    ctx.fillRect(cx - s, cy - s, s * 0.3, s * 2);
    // Porch columns
    ctx.fillStyle = `rgba(140,120,90,${tAlpha * 0.4})`;
    for (let i = 0; i < 4; i++) {
      const py = cy - s + i * s * 0.6 + s * 0.15;
      ctx.fillRect(cx - s + s * 0.28, py, 4, 4);
    }
  }

  // People ‚Äî appear as courtyard becomes alive
  if (aliveness > 30) {
    const nPeople = Math.floor((aliveness - 30) / 15) + 1;
    ctx.fillStyle = `rgba(200,180,140,${clamp((aliveness-30)/70, 0.2, 0.7)})`;
    const positions = [[cx-s*0.3, cy-s*0.2], [cx+s*0.4, cy+s*0.3], [cx, cy-s*0.5], [cx+s*0.2, cy], [cx-s*0.5, cy+s*0.4]];
    for (let i = 0; i < Math.min(nPeople, positions.length); i++) {
      ctx.beginPath();
      ctx.arc(positions[i][0], positions[i][1], 5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Warm glow
  if (aliveness > 40) {
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, s);
    const gAlpha = (aliveness - 40) / 200;
    grad.addColorStop(0, `rgba(200,170,100,${gAlpha})`);
    grad.addColorStop(1, 'rgba(200,170,100,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(cx - s, cy - s, s * 2, s * 2);
  }

  // Text
  const txt = document.getElementById('forcesText');
  if (aliveness < 20) txt.textContent = "The courtyard is enclosed and dead. No one wants to be here.";
  else if (aliveness < 40) txt.textContent = "Something stirs. But the forces still conflict.";
  else if (aliveness < 60) txt.textContent = "People begin to linger. The courtyard starts to breathe.";
  else if (aliveness < 80) txt.textContent = "The forces are nearly resolved. The courtyard feels comfortable.";
  else txt.textContent = "The courtyard is alive. People come here naturally. It sustains itself.";
}
updateForces();

// ===== 4. PATTERN LANGUAGE BUILDER =====
const selectedPatterns = new Set();

function togglePattern(el) {
  const p = el.dataset.pat;
  if (selectedPatterns.has(p)) { selectedPatterns.delete(p); el.classList.remove('selected'); }
  else { selectedPatterns.add(p); el.classList.add('selected'); }
  drawLanguage();
}

function drawLanguage() {
  const c = document.getElementById('langCanvas');
  const ctx = c.getContext('2d');
  const dpr = devicePixelRatio;
  c.width = c.offsetWidth * dpr;
  c.height = 300 * dpr;
  const W = c.width, H = c.height;

  ctx.fillStyle = '#12121a';
  ctx.fillRect(0, 0, W, H);

  const pats = Array.from(selectedPatterns);
  const n = pats.length;
  const aliveness = n / 12;

  // Meter
  const mf = document.getElementById('meterFill');
  mf.style.width = (aliveness * 100) + '%';
  const hue = aliveness < 0.3 ? '0' : aliveness < 0.6 ? '30' : '100';
  mf.style.background = `hsl(${hue}, 50%, 50%)`;

  if (n === 0) {
    ctx.fillStyle = '#3a3a45';
    ctx.font = `${14 * dpr}px Georgia`;
    ctx.textAlign = 'center';
    ctx.fillText('Select patterns to generate a building', W/2, H/2);
    return;
  }

  // Draw a building that emerges from patterns
  const bx = W * 0.15, by = H * 0.85, bw = W * 0.7, bh = H * 0.65;

  // Ground
  ctx.fillStyle = '#1a1a22';
  ctx.fillRect(0, by, W, H - by);

  // Main structure
  ctx.fillStyle = '#1e1e28';
  ctx.fillRect(bx, by - bh, bw, bh);
  ctx.strokeStyle = '#3a3a45';
  ctx.lineWidth = 1;
  ctx.strokeRect(bx, by - bh, bw, bh);

  // Roof
  if (pats.includes('roof')) {
    ctx.fillStyle = '#2a2520';
    ctx.beginPath();
    ctx.moveTo(bx - 15, by - bh);
    ctx.lineTo(bx + bw/2, by - bh - bh * 0.35);
    ctx.lineTo(bx + bw + 15, by - bh);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#4a4535';
    ctx.stroke();
  }

  // Courtyard
  if (pats.includes('courtyard')) {
    ctx.fillStyle = '#151520';
    const cw = bw * 0.3, ch = bh * 0.3;
    ctx.fillRect(bx + bw/2 - cw/2, by - bh/2 - ch/2, cw, ch);
    ctx.strokeStyle = '#3a3a45';
    ctx.strokeRect(bx + bw/2 - cw/2, by - bh/2 - ch/2, cw, ch);
  }

  // Windows
  if (pats.includes('window-place') || pats.includes('light')) {
    const nw = pats.includes('light') ? 4 : 2;
    const twoSides = pats.includes('light');
    for (let i = 0; i < nw; i++) {
      const wx = bx + bw * (0.15 + i * 0.22);
      const wy = by - bh * 0.7;
      const ww = bw * 0.12, wh = bh * 0.2;

      if (pats.includes('window-place')) {
        // Bay window
        ctx.fillStyle = '#2a2520';
        ctx.fillRect(wx - 4, wy - 8, ww + 8, wh + 16);
        ctx.fillStyle = 'rgba(200,170,100,0.1)';
        ctx.fillRect(wx, wy, ww, wh);
      } else {
        ctx.fillStyle = 'rgba(140,150,180,0.08)';
        ctx.fillRect(wx, wy, ww, wh);
      }
      ctx.strokeStyle = '#4a4535';
      ctx.lineWidth = 1;
      ctx.strokeRect(wx, wy, ww, wh);
    }
  }

  // Entrance
  if (pats.includes('entrance')) {
    const ex = bx + bw/2 - bw * 0.06;
    const ew = bw * 0.12, eh = bh * 0.25;
    ctx.fillStyle = '#0e0e16';
    ctx.fillRect(ex, by - eh, ew, eh);
    // Transition depth
    ctx.fillStyle = 'rgba(140,120,90,0.1)';
    ctx.fillRect(ex - 10, by - eh - 10, ew + 20, 15);
  }

  // Columns
  if (pats.includes('columns')) {
    ctx.fillStyle = '#4a4535';
    for (let i = 0; i < 3; i++) {
      const cx = bx + bw * (0.2 + i * 0.3);
      ctx.fillRect(cx, by - bh * 0.4, 6, bh * 0.4);
      // Capital
      ctx.fillRect(cx - 3, by - bh * 0.4, 12, 4);
    }
  }

  // Garden
  if (pats.includes('garden')) {
    ctx.fillStyle = '#2a3a2a';
    // Bushes
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      ctx.arc(bx - 20 + i * 15, by - 5, 8 + Math.random() * 5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = '#3a5a3a';
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(bx + bw + 10 + i * 12, by - 8, 10, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Building edge
  if (pats.includes('edge')) {
    ctx.fillStyle = 'rgba(140,120,90,0.08)';
    ctx.fillRect(bx - 25, by - bh * 0.15, 25, bh * 0.15);
    ctx.fillRect(bx + bw, by - bh * 0.15, 25, bh * 0.15);
  }

  // Sunny place
  if (pats.includes('sunny-place')) {
    const grad = ctx.createRadialGradient(bx + bw * 0.8, by - bh * 0.2, 5, bx + bw * 0.8, by - bh * 0.2, 80);
    grad.addColorStop(0, 'rgba(220,200,120,0.12)');
    grad.addColorStop(1, 'rgba(220,200,120,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(bx, by - bh, bw + 60, bh + 20);
  }

  // Alcoves
  if (pats.includes('alcove')) {
    ctx.fillStyle = '#1a1822';
    ctx.fillRect(bx + 8, by - bh * 0.35, bw * 0.12, bh * 0.18);
    ctx.fillRect(bx + bw - bw * 0.12 - 8, by - bh * 0.35, bw * 0.12, bh * 0.18);
  }

  // Ceiling heights
  if (pats.includes('ceiling')) {
    ctx.strokeStyle = 'rgba(100,95,85,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    ctx.beginPath();
    ctx.moveTo(bx + bw * 0.35, by - bh * 0.4);
    ctx.lineTo(bx + bw * 0.35, by - bh * 0.8);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bx + bw * 0.65, by - bh * 0.4);
    ctx.lineTo(bx + bw * 0.65, by - bh * 0.9);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Ornament
  if (pats.includes('ornament')) {
    ctx.fillStyle = 'rgba(196,149,106,0.3)';
    // Small decorative marks
    for (let i = 0; i < 6; i++) {
      const ox = bx + bw * 0.1 + i * bw * 0.15;
      ctx.beginPath();
      ctx.arc(ox, by - bh + 8, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    if (pats.includes('entrance')) {
      const ex = bx + bw/2;
      // Arch over entrance
      ctx.strokeStyle = 'rgba(196,149,106,0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(ex, by - bh * 0.25, bw * 0.08, Math.PI, 0);
      ctx.stroke();
    }
  }
}
drawLanguage();

// ===== 5. DIFFERENTIATING SPACE =====
let diffAnim = null;

function runDiff(mode) {
  document.getElementById('btnOrganic').classList.toggle('active', mode === 'organic');
  document.getElementById('btnModular').classList.toggle('active', mode === 'modular');

  if (diffAnim) cancelAnimationFrame(diffAnim);

  const c = document.getElementById('diffCanvas');
  const ctx = c.getContext('2d');
  const dpr = devicePixelRatio;
  c.width = c.offsetWidth * dpr;
  c.height = 350 * dpr;
  const W = c.width, H = c.height;

  let step = 0;
  const maxSteps = mode === 'organic' ? 120 : 80;

  // Organic: space differentiates from whole
  // Modular: boxes assemble from parts
  const organicRects = [];
  const modularBoxes = [];

  if (mode === 'organic') {
    // Start with one big space, recursively subdivide
    organicRects.push({ x: W*0.1, y: H*0.1, w: W*0.8, h: H*0.8, depth: 0, split: false, splitAt: 15 + Math.random()*10 });
  } else {
    // Modular boxes appear one by one
    const cols = 5, rows = 3;
    const bw = W * 0.14, bh = H * 0.22;
    for (let r = 0; r < rows; r++) {
      for (let cl = 0; cl < cols; cl++) {
        modularBoxes.push({
          x: W*0.1 + cl * (bw + W*0.02),
          y: H*0.1 + r * (bh + H*0.04),
          w: bw, h: bh,
          appear: (r * cols + cl) * 5 + 5
        });
      }
    }
  }

  function splitRect(rect, step) {
    if (rect.depth > 4) return;
    const isVert = rect.w > rect.h;
    // Slightly irregular split point
    const ratio = 0.35 + Math.random() * 0.3;
    if (isVert) {
      const sw = rect.w * ratio;
      organicRects.push({
        x: rect.x, y: rect.y, w: sw - 2, h: rect.h,
        depth: rect.depth + 1, split: false,
        splitAt: step + 12 + Math.random() * 15
      });
      organicRects.push({
        x: rect.x + sw + 2, y: rect.y, w: rect.w - sw - 2, h: rect.h,
        depth: rect.depth + 1, split: false,
        splitAt: step + 15 + Math.random() * 20
      });
    } else {
      const sh = rect.h * ratio;
      organicRects.push({
        x: rect.x, y: rect.y, w: rect.w, h: sh - 2,
        depth: rect.depth + 1, split: false,
        splitAt: step + 12 + Math.random() * 15
      });
      organicRects.push({
        x: rect.x, y: rect.y + sh + 2, w: rect.w, h: rect.h - sh - 2,
        depth: rect.depth + 1, split: false,
        splitAt: step + 15 + Math.random() * 20
      });
    }
    rect.split = true;
  }

  function animate() {
    step++;
    ctx.fillStyle = '#12121a';
    ctx.fillRect(0, 0, W, H);

    if (mode === 'organic') {
      // Check for splits
      organicRects.forEach(r => {
        if (!r.split && step >= r.splitAt && r.depth < 4) {
          splitRect(r, step);
        }
      });

      // Draw all unsplit rects
      organicRects.forEach(r => {
        if (r.split) return;
        const depth = r.depth;
        const warmth = depth * 0.03;
        ctx.fillStyle = `rgba(${40 + depth*8}, ${35 + depth*5}, ${25 + depth*8}, ${0.6 + depth * 0.08})`;
        // Slightly irregular ‚Äî add tiny random offsets
        const jx = (Math.random() - 0.5) * 2;
        const jy = (Math.random() - 0.5) * 2;
        ctx.fillRect(r.x + jx, r.y + jy, r.w, r.h);
        ctx.strokeStyle = `rgba(100,90,70,${0.3 + depth * 0.1})`;
        ctx.lineWidth = 1;
        ctx.strokeRect(r.x + jx, r.y + jy, r.w, r.h);
      });

      // Label
      ctx.fillStyle = 'rgba(122,158,126,0.5)';
      ctx.font = `${11 * dpr}px Georgia`;
      ctx.textAlign = 'center';
      ctx.fillText('Space differentiates ‚Äî the whole gives birth to parts', W/2, H - 15 * dpr);

    } else {
      // Modular: identical boxes appear
      modularBoxes.forEach(b => {
        if (step < b.appear) return;
        const alpha = clamp((step - b.appear) / 10, 0, 1);
        ctx.fillStyle = `rgba(30,30,45,${alpha})`;
        ctx.fillRect(b.x, b.y, b.w, b.h);
        ctx.strokeStyle = `rgba(80,80,100,${alpha * 0.5})`;
        ctx.lineWidth = 1;
        ctx.strokeRect(b.x, b.y, b.w, b.h);
      });

      ctx.fillStyle = 'rgba(186,106,106,0.5)';
      ctx.font = `${11 * dpr}px Georgia`;
      ctx.textAlign = 'center';
      ctx.fillText('Parts are assembled ‚Äî identical, interchangeable, dead', W/2, H - 15 * dpr);
    }

    if (step < maxSteps) diffAnim = requestAnimationFrame(animate);
  }
  animate();
}
runDiff('organic');

// ===== 6. REPAIR TIMELINE =====
function updateRepair() {
  const t = +document.getElementById('repairSlider').value / 100;
  const year = Math.floor(1 + t * 99);
  document.getElementById('repairYear').textContent = `Year ${year}`;

  const c = document.getElementById('repairCanvas');
  const ctx = c.getContext('2d');
  const dpr = devicePixelRatio;
  c.width = c.offsetWidth * dpr;
  c.height = 300 * dpr;
  const W = c.width, H = c.height;

  ctx.fillStyle = '#0e0e16';
  ctx.fillRect(0, 0, W, H);

  // Seed random based on time parameter for consistency
  function seeded(i) { return ((Math.sin(i * 127.1 + 311.7) * 43758.5453) % 1 + 1) % 1; }

  const groundY = H * 0.75;

  // Ground
  ctx.fillStyle = '#1a1a22';
  ctx.fillRect(0, groundY, W, H - groundY);

  // Grass grows
  if (t > 0.1) {
    ctx.fillStyle = `rgba(60,90,50,${clamp(t * 0.6, 0, 0.4)})`;
    for (let i = 0; i < 40; i++) {
      const gx = seeded(i) * W;
      const gh = 3 + seeded(i + 100) * 8 * t;
      ctx.fillRect(gx, groundY - gh, 2, gh);
    }
  }

  // Buildings appear over time
  const buildings = [
    { x: 0.1, w: 0.12, h: 0.25, appear: 0 },
    { x: 0.25, w: 0.15, h: 0.3, appear: 0.1 },
    { x: 0.45, w: 0.1, h: 0.2, appear: 0.2 },
    { x: 0.58, w: 0.18, h: 0.35, appear: 0.15 },
    { x: 0.8, w: 0.12, h: 0.22, appear: 0.3 },
  ];

  buildings.forEach((b, bi) => {
    if (t < b.appear) return;
    const age = (t - b.appear) / (1 - b.appear);
    const bx = b.x * W, bw = b.w * W;
    const bh = b.h * H * clamp(age * 2, 0, 1);
    const by = groundY - bh;

    // Building grows
    ctx.fillStyle = `rgba(35,32,28,${clamp(age, 0.3, 0.9)})`;
    ctx.fillRect(bx, by, bw, bh);
    ctx.strokeStyle = `rgba(80,72,60,${clamp(age, 0.2, 0.6)})`;
    ctx.lineWidth = 1;
    ctx.strokeRect(bx, by, bw, bh);

    // Roof appears later
    if (age > 0.3) {
      ctx.fillStyle = `rgba(50,40,30,${clamp((age-0.3)*2, 0, 0.8)})`;
      ctx.beginPath();
      ctx.moveTo(bx - 5, by);
      ctx.lineTo(bx + bw/2, by - bh * 0.25);
      ctx.lineTo(bx + bw + 5, by);
      ctx.closePath();
      ctx.fill();
    }

    // Windows appear even later
    if (age > 0.4) {
      const nw = Math.floor(bw / (W * 0.04));
      for (let i = 0; i < nw; i++) {
        const wx = bx + bw * 0.15 + i * bw * 0.25;
        const wy = by + bh * 0.2;
        const ws = Math.min(bw * 0.15, W * 0.03);
        ctx.fillStyle = `rgba(180,160,100,${clamp((age-0.4)*2, 0, 0.15)})`;
        ctx.fillRect(wx, wy, ws, ws * 1.3);
      }
    }

    // Modifications and repairs ‚Äî details accumulate
    if (age > 0.6) {
      // Extension
      ctx.fillStyle = `rgba(40,36,30,${clamp((age-0.6)*2, 0, 0.7)})`;
      const ew = bw * 0.3;
      ctx.fillRect(bx + bw, by + bh * 0.4, ew, bh * 0.6);
    }

    if (age > 0.8) {
      // Garden wall
      ctx.fillStyle = `rgba(60,55,45,${clamp((age-0.8)*5, 0, 0.5)})`;
      ctx.fillRect(bx - 8, groundY - 15, 5, 15);
      ctx.fillRect(bx + bw + bw * 0.3, groundY - 12, 5, 12);
    }
  });

  // Trees grow
  const trees = [
    { x: 0.05, appear: 0.05 },
    { x: 0.42, appear: 0.25 },
    { x: 0.55, appear: 0.4 },
    { x: 0.76, appear: 0.35 },
    { x: 0.95, appear: 0.15 },
  ];

  trees.forEach((tr) => {
    if (t < tr.appear) return;
    const age = clamp((t - tr.appear) / (1 - tr.appear), 0, 1);
    const tx = tr.x * W;
    const th = 30 + age * 80;
    // Trunk
    ctx.fillStyle = `rgba(60,45,30,${clamp(age, 0.2, 0.7)})`;
    ctx.fillRect(tx - 2, groundY - th, 4, th);
    // Canopy
    ctx.fillStyle = `rgba(50,80,45,${clamp(age, 0.1, 0.5)})`;
    ctx.beginPath();
    ctx.arc(tx, groundY - th, 12 + age * 18, 0, Math.PI * 2);
    ctx.fill();
  });

  // Paths between buildings
  if (t > 0.3) {
    ctx.strokeStyle = `rgba(120,110,90,${clamp((t-0.3)*1.5, 0, 0.25)})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([3, 5]);
    ctx.beginPath();
    ctx.moveTo(W * 0.15, groundY + 5);
    ctx.lineTo(W * 0.85, groundY + 5);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // People walking (late)
  if (t > 0.5) {
    const np = Math.floor((t - 0.5) * 10);
    ctx.fillStyle = `rgba(200,180,140,${clamp((t-0.5)*1.5, 0, 0.5)})`;
    for (let i = 0; i < Math.min(np, 5); i++) {
      ctx.beginPath();
      ctx.arc(W * (0.2 + seeded(i + 50) * 0.6), groundY + 3, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}
updateRepair();

// ===== 7. FISH POND =====
(function() {
  const c = document.getElementById('pondCanvas');
  const ctx = c.getContext('2d');
  const dpr = devicePixelRatio;

  function resize() {
    c.width = c.offsetWidth * dpr;
    c.height = 400 * dpr;
  }
  resize();
  window.addEventListener('resize', resize);

  const fish = [];
  const colors = ['#d4845a','#c4a04a','#8a6aaa','#3a3a3a','#d49a3a','#aa7a3a','#ba8a5a','#6a5a8a'];

  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    fish.push({
      angle,
      radius: 50 + Math.random() * 30,
      speed: 0.003 + Math.random() * 0.004,
      size: 12 + Math.random() * 8,
      color: colors[i],
      wobble: Math.random() * Math.PI * 2,
      wobbleSpeed: 0.02 + Math.random() * 0.01
    });
  }

  let time = 0;
  let ripples = [];

  c.addEventListener('click', (e) => {
    const rect = c.getBoundingClientRect();
    ripples.push({
      x: (e.clientX - rect.left) * dpr,
      y: (e.clientY - rect.top) * dpr,
      r: 0, alpha: 0.5
    });
  });

  function draw() {
    time++;
    const W = c.width, H = c.height;
    const cx = W / 2, cy = H / 2;

    // Water
    ctx.fillStyle = '#0a1520';
    ctx.fillRect(0, 0, W, H);

    // Pond border (stone)
    ctx.strokeStyle = '#3a3530';
    ctx.lineWidth = 8;
    const px = W * 0.1, py = H * 0.08, pw = W * 0.8, ph = H * 0.84;
    ctx.strokeRect(px, py, pw, ph);

    // Water surface ripples
    ctx.strokeStyle = 'rgba(60,80,100,0.15)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
      const ry = py + ph * 0.2 + i * ph * 0.15;
      ctx.beginPath();
      for (let x = px; x < px + pw; x += 3) {
        const wave = Math.sin(x * 0.02 + time * 0.02 + i) * 3;
        if (x === px) ctx.moveTo(x, ry + wave);
        else ctx.lineTo(x, ry + wave);
      }
      ctx.stroke();
    }

    // Wooden circle underwater
    ctx.strokeStyle = 'rgba(80,60,40,0.3)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(cx + W * 0.05, cy + H * 0.05, Math.min(W, H) * 0.12, 0, Math.PI * 2);
    ctx.stroke();

    // Flowers at one end
    const flowerColors = ['#d45a7a','#da6a5a','#e48a6a','#c45a6a','#d47a8a'];
    for (let i = 0; i < 6; i++) {
      const fx = px + 15 + i * 18;
      const fy = py + 15;
      ctx.fillStyle = '#3a5a3a';
      ctx.fillRect(fx, fy, 2, 15);
      ctx.fillStyle = flowerColors[i % flowerColors.length];
      ctx.beginPath();
      ctx.arc(fx + 1, fy - 2, 5 + Math.sin(time * 0.03 + i) * 1, 0, Math.PI * 2);
      ctx.fill();
    }

    // Fish
    const circleCx = cx + W * 0.05;
    const circleCy = cy + H * 0.05;

    fish.forEach((f, i) => {
      f.angle += f.speed;
      f.wobble += f.wobbleSpeed;

      // Fish swim in circles, sometimes inside the wooden circle
      const r = f.radius + Math.sin(f.wobble) * 15;
      const fx = circleCx + Math.cos(f.angle) * r;
      const fy = circleCy + Math.sin(f.angle) * r * 0.6; // Slightly elliptical

      // Fish body
      const bodyAngle = f.angle + Math.PI / 2;
      ctx.save();
      ctx.translate(fx, fy);
      ctx.rotate(bodyAngle + Math.sin(f.wobble) * 0.15);

      // Body
      ctx.fillStyle = f.color;
      ctx.beginPath();
      ctx.ellipse(0, 0, f.size, f.size * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Tail
      ctx.beginPath();
      ctx.moveTo(-f.size, 0);
      ctx.lineTo(-f.size - f.size * 0.5, -f.size * 0.3);
      ctx.lineTo(-f.size - f.size * 0.5, f.size * 0.3);
      ctx.closePath();
      ctx.fill();

      // Eye
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(f.size * 0.5, -f.size * 0.1, 2, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // Subtle wake
      ctx.strokeStyle = `rgba(80,100,120,0.08)`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(fx, fy, f.size + 5, 0, Math.PI * 2);
      ctx.stroke();
    });

    // Click ripples
    ripples = ripples.filter(r => r.alpha > 0.01);
    ripples.forEach(r => {
      r.r += 1.5;
      r.alpha *= 0.97;
      ctx.strokeStyle = `rgba(120,140,160,${r.alpha})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI * 2);
      ctx.stroke();
    });

    // Subtle light shimmer
    const shimmer = ctx.createRadialGradient(cx - W*0.1, cy - H*0.15, 10, cx, cy, Math.min(W,H)*0.4);
    shimmer.addColorStop(0, `rgba(120,140,160,${0.03 + Math.sin(time*0.01)*0.01})`);
    shimmer.addColorStop(1, 'rgba(120,140,160,0)');
    ctx.fillStyle = shimmer;
    ctx.fillRect(px, py, pw, ph);

    requestAnimationFrame(draw);
  }
  draw();
})();

// Handle resize for canvases
window.addEventListener('resize', () => {
  updateForces();
  drawLanguage();
  updateRepair();
});
</script>
</body>
</html>
