<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Excalidraw Interview Replay ‚Äì Drawer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0d1117; color: #e6edf3; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow: hidden; height: 100vh; height: 100dvh; touch-action: none; }

  /* --- Full-screen canvas --- */
  .canvas-area { position: absolute; inset: 0; z-index: 1; }
  #excalidraw-container { width: 100%; height: 100%; }
  #excalidraw-container .excalidraw { width: 100%; height: 100%; }
  #excalidraw-container .excalidraw .layer-ui__wrapper { display: none !important; }
  #excalidraw-container .excalidraw .App-menu { display: none !important; }
  #excalidraw-container .excalidraw .HintViewer { display: none !important; }
  #excalidraw-container .excalidraw .Island { display: none !important; }

  .canvas-hud { position: absolute; top: 12px; right: 16px; z-index: 10; display: flex; flex-direction: column; gap: 6px; align-items: flex-end; }
  .canvas-label { font-size: 11px; color: #484f58; background: #161b2299; padding: 4px 10px; border-radius: 4px; }
  .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; background: #0d1117; z-index: 5; font-size: 14px; color: #8b949e; }
  .loading-overlay.hidden { display: none; }

  /* --- Header overlay (top) --- */
  .header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    height: 44px; background: #161b22ee; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    border-bottom: 1px solid #30363d;
    display: flex; align-items: center; padding: 0 12px; gap: 8px;
  }
  .header h1 { font-size: 13px; font-weight: 600; white-space: nowrap; }
  .header .badge { font-size: 10px; padding: 2px 6px; border-radius: 10px; }
  .badge.ready { background: #238636; color: #fff; }
  .badge.playing { background: #1f6feb; color: #fff; }
  .badge.done { background: #3fb950; color: #fff; }
  .badge.intervention { background: #e8590c; color: #fff; }
  .model-select { background: #21262d; border: 1px solid #30363d; color: #e6edf3; padding: 4px 6px; border-radius: 4px; font-size: 11px; margin-left: auto; max-width: 160px; }

  /* --- Controls overlay (bottom, above drawer) --- */
  .controls {
    position: fixed; bottom: 0; left: 0; right: 0; z-index: 200;
    height: 54px; background: #161b22ee; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    border-top: 1px solid #30363d;
    display: flex; align-items: center; padding: 0 10px; gap: 8px;
    transition: bottom 0.3s cubic-bezier(.25,.8,.25,1);
  }
  .play-btn { width: 34px; height: 34px; border-radius: 50%; border: none; cursor: pointer; background: #238636; color: #fff; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: all 0.15s; flex-shrink: 0; }
  .play-btn:hover { background: #2ea043; }
  .play-btn.playing { background: #da3633; }
  .stage-pips { display: flex; gap: 2px; flex-shrink: 0; overflow-x: auto; max-width: 30%; }
  .pip { width: 20px; height: 5px; border-radius: 3px; background: #30363d; transition: background 0.3s; cursor: pointer; position: relative; flex-shrink: 0; }
  .pip.done { background: #3fb950; }
  .pip.current { background: #388bfd; box-shadow: 0 0 6px #388bfd; }
  .pip.intervention { background: #e8590c; }
  .pip.vision { background: #d4a017; }
  .pip:hover { background: #8b949e; }
  .progress-wrap { flex: 1; height: 4px; background: #21262d; border-radius: 2px; cursor: pointer; position: relative; min-width: 40px; }
  .progress-fill { height: 100%; background: linear-gradient(90deg, #1f6feb, #388bfd); border-radius: 2px; transition: width 0.1s linear; }
  .timer { font-size: 11px; color: #8b949e; font-variant-numeric: tabular-nums; min-width: 65px; text-align: right; flex-shrink: 0; }
  .speed-ctrl { display: flex; align-items: center; gap: 4px; flex-shrink: 0; }
  .speed-ctrl label { font-size: 10px; color: #8b949e; }
  .speed-ctrl input { width: 50px; accent-color: #388bfd; }
  .speed-val { font-size: 11px; color: #e6edf3; min-width: 24px; }
  .reset-btn { background: #21262d; border: 1px solid #30363d; color: #8b949e; padding: 3px 8px; border-radius: 4px; font-size: 10px; cursor: pointer; flex-shrink: 0; }
  .reset-btn:hover { color: #e6edf3; border-color: #8b949e; }

  /* Hide speed on very small screens */
  @media (max-width: 480px) {
    .speed-ctrl { display: none; }
    .reset-btn { display: none; }
  }

  /* --- Bottom Sheet / Drawer --- */
  .drawer {
    position: fixed; left: 0; right: 0; bottom: 54px; z-index: 150;
    background: #161b22; border-top: 1px solid #30363d;
    border-radius: 14px 14px 0 0;
    display: flex; flex-direction: column;
    transform: translateY(calc(100% - 36px)); /* collapsed: only handle visible */
    transition: transform 0.35s cubic-bezier(.25,.8,.25,1);
    max-height: calc(100dvh - 44px - 54px);
    will-change: transform;
  }
  .drawer.peek {
    transform: translateY(60%);
  }
  .drawer.open {
    transform: translateY(0);
  }
  .drawer.dragging {
    transition: none;
  }

  .drawer-handle {
    display: flex; align-items: center; justify-content: center;
    height: 36px; cursor: grab; flex-shrink: 0;
    touch-action: none;
  }
  .drawer-handle::before {
    content: ''; display: block; width: 36px; height: 4px;
    background: #484f58; border-radius: 2px;
  }
  .drawer-handle-label {
    position: absolute; left: 12px; top: 10px;
    font-size: 11px; color: #8b949e; text-transform: uppercase; letter-spacing: 1px;
    pointer-events: none;
  }

  .chat-header {
    padding: 0 12px 6px; font-size: 11px; color: #8b949e; text-transform: uppercase; letter-spacing: 1px;
    flex-shrink: 0; display: flex; align-items: center; gap: 6px;
    border-bottom: 1px solid #21262d;
  }
  .chat-header .stage-badge { font-size: 10px; padding: 1px 6px; border-radius: 8px; text-transform: none; letter-spacing: 0; color: #fff; }
  .stage-badge.normal { background: #1f6feb; }
  .stage-badge.intervention { background: #e8590c; }
  .stage-badge.review { background: #9c36b5; }
  .stage-badge.vision { background: #d4a017; }

  .chat-messages {
    flex: 1; overflow-y: auto; padding: 10px 12px; display: flex; flex-direction: column; gap: 8px;
    -webkit-overflow-scrolling: touch; overscroll-behavior: contain;
  }

  .msg { padding: 10px 14px; border-radius: 14px; font-size: 13px; line-height: 1.5; max-width: 95%; animation: msgIn 0.3s ease; word-wrap: break-word; }
  @keyframes msgIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }
  .msg.human { background: #1f6feb18; border: 1px solid #1f6feb33; align-self: flex-end; border-bottom-right-radius: 4px; }
  .msg.interviewer { background: #e8590c18; border: 1px solid #e8590c33; align-self: flex-end; border-bottom-right-radius: 4px; }
  .msg.vision-prompt { background: #d4a01718; border: 1px solid #d4a01733; align-self: flex-end; border-bottom-right-radius: 4px; }
  .msg.model { background: #21262d; border: 1px solid #30363d; align-self: flex-start; border-bottom-left-radius: 4px; }
  .msg .sender { font-size: 11px; font-weight: 600; margin-bottom: 4px; display: flex; align-items: center; gap: 6px; }
  .msg .sender.human-name { color: #388bfd; }
  .msg .sender.interviewer-name { color: #e8590c; }
  .msg .sender.vision-name { color: #d4a017; }
  .msg .sender.model-name { color: #3fb950; }
  .msg .meta { font-size: 10px; color: #484f58; margin-top: 4px; display: flex; gap: 8px; }
  .msg .meta span { display: inline-flex; align-items: center; gap: 3px; }
  .msg.thinking { color: #8b949e; font-style: italic; }
  .msg.thinking .dots::after { content: '...'; animation: dots 1.5s infinite; }
  @keyframes dots { 0%,20% { content: '.'; } 40% { content: '..'; } 60%,100% { content: '...'; } }
  .msg .reasoning { white-space: pre-wrap; }
  .msg .diagram-note { margin-top: 6px; padding: 4px 8px; background: #0d111766; border-radius: 6px; font-size: 11px; color: #8b949e; }
  .msg .diagram-note .count { color: #3fb950; font-weight: 600; }
  .cursor { display: inline-block; width: 2px; height: 14px; background: #3fb950; animation: blink 0.6s infinite; vertical-align: text-bottom; margin-left: 1px; }
  @keyframes blink { 0%,50% { opacity: 1; } 51%,100% { opacity: 0; } }

  /* safe area for notch devices */
  @supports (padding-bottom: env(safe-area-inset-bottom)) {
    .controls { padding-bottom: env(safe-area-inset-bottom); }
  }
</style>
</head>
<body>

<!-- Header overlay -->
<div class="header">
  <h1>üé¨ Replay</h1>
  <span class="badge ready" id="badge">Ready</span>
  <select class="model-select" id="model-select" onchange="selectModel(this.value)"></select>
</div>

<!-- Full-screen canvas -->
<div class="canvas-area">
  <div class="canvas-hud">
    <div class="canvas-label" id="canvas-label">Canvas ¬∑ 0 elements</div>
  </div>
  <div class="loading-overlay" id="loading">Loading Excalidraw library...</div>
  <div id="excalidraw-container"></div>
</div>

<!-- Bottom sheet / drawer for chat -->
<div class="drawer" id="drawer">
  <div class="drawer-handle" id="drawer-handle">
    <span class="drawer-handle-label">üí¨ Chat</span>
  </div>
  <div class="chat-header">üí¨ Interview <span class="stage-badge normal" id="stage-label">Stage 0/0</span></div>
  <div class="chat-messages" id="chat"></div>
</div>

<!-- Controls bar at very bottom -->
<div class="controls">
  <button class="play-btn" id="play-btn" onclick="togglePlay()">‚ñ∂</button>
  <div class="stage-pips" id="pips"></div>
  <div class="progress-wrap" id="pbar" onclick="seekTo(event)">
    <div class="progress-fill" id="pfill"></div>
  </div>
  <div class="timer" id="timer">0:00 / 0:00</div>
  <div class="speed-ctrl">
    <label>Speed</label>
    <input type="range" id="speed" min="0.5" max="10" step="0.5" value="2" oninput="setSpeed()">
    <span class="speed-val" id="speed-val">2√ó</span>
  </div>
  <button class="reset-btn" onclick="resetReplay()">‚Ü∫</button>
</div>

<!-- Drawer drag logic -->
<script>
(function() {
  const drawer = document.getElementById('drawer');
  const handle = document.getElementById('drawer-handle');
  let state = 'collapsed'; // collapsed | peek | open
  let startY = 0, startTranslate = 0, dragging = false;
  const chatEl = document.getElementById('chat');

  function getDrawerHeight() { return drawer.offsetHeight; }
  function getMaxTranslate() { return getDrawerHeight() - 36; } // collapsed shows 36px

  function snapTo(s) {
    state = s;
    drawer.classList.remove('collapsed','peek','open','dragging');
    if (s === 'peek') drawer.classList.add('peek');
    else if (s === 'open') drawer.classList.add('open');
    // collapsed = no class = default transform
  }

  handle.addEventListener('pointerdown', function(e) {
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    dragging = true;
    startY = e.clientY;
    const style = getComputedStyle(drawer);
    const matrix = new DOMMatrix(style.transform);
    startTranslate = matrix.m42;
    drawer.classList.add('dragging');
    handle.setPointerCapture(e.pointerId);
    e.preventDefault();
  });

  handle.addEventListener('pointermove', function(e) {
    if (!dragging) return;
    const dy = e.clientY - startY;
    const newY = Math.max(0, Math.min(getMaxTranslate(), startTranslate + dy));
    drawer.style.transform = `translateY(${newY}px)`;
  });

  handle.addEventListener('pointerup', function(e) {
    if (!dragging) return;
    dragging = false;
    drawer.classList.remove('dragging');
    drawer.style.transform = '';
    const style = getComputedStyle(drawer);
    const matrix = new DOMMatrix(style.transform);
    const currentY = matrix.m42;
    const maxT = getMaxTranslate();
    const pct = currentY / maxT;

    if (pct < 0.25) snapTo('open');
    else if (pct < 0.7) snapTo('peek');
    else snapTo('collapsed');
  });

  handle.addEventListener('pointercancel', function() {
    dragging = false;
    drawer.classList.remove('dragging');
    drawer.style.transform = '';
  });

  // Tap to cycle: collapsed -> peek -> open -> collapsed
  handle.addEventListener('click', function(e) {
    if (Math.abs(e.clientY - startY) > 5) return; // was a drag
    if (state === 'collapsed') snapTo('peek');
    else if (state === 'peek') snapTo('open');
    else snapTo('collapsed');
  });

  // Prevent canvas interaction when scrolling chat
  chatEl.addEventListener('touchmove', function(e) { e.stopPropagation(); }, { passive: true });
})();
</script>

<script>
window.EXCALIDRAW_ASSET_PATH = "https://esm.sh/@excalidraw/excalidraw/dist/prod/";
</script>

<script>
let DATA = {};
let model = null, playing = false, speed = 2;
let stageIdx = 0, elapsed = 0, stageStartTime = 0, animFrame = null;
let currentExcalidrawElements = [];
let totalDuration = 0;
let textCharIdx = 0;
let msgCounter = 0;
let excalidrawAPI = null;
let excalidrawReady = false;

// Convert our element format to Excalidraw format
function toExcalidrawElements(elements) {
  const result = [];
  const seedBase = 42;
  let seedCounter = 0;
  
  elements.forEach(el => {
    const seed = seedBase + (seedCounter++);
    const baseProps = {
      groupIds: [],
      frameId: null,
      roundness: { type: 3 },
      isDeleted: false,
      version: 1,
      versionNonce: seed,
      updated: Date.now(),
      link: null,
      locked: false,
    };
    
    if (el.type === 'rectangle' || el.type === 'rect') {
      const rect = {
        ...baseProps,
        type: "rectangle",
        id: el.id,
        x: el.x,
        y: el.y,
        width: el.w,
        height: el.h,
        strokeColor: el.color || "#1971c2",
        backgroundColor: (el.bg && el.bg !== 'transparent') ? el.bg : "transparent",
        fillStyle: "solid",
        strokeWidth: 2,
        roughness: 1,
        opacity: 100,
        angle: 0,
        seed: seed * 1000 + 1,
        boundElements: el.label ? [{ type: "text", id: el.id + "_label" }] : [],
      };
      result.push(rect);
      
      if (el.label) {
        const fontSize = 16;
        const lines = String(el.label).split('\n');
        const textHeight = lines.length * fontSize * 1.25;
        result.push({
          ...baseProps,
          type: "text",
          id: el.id + "_label",
          x: el.x + el.w / 2 - (el.w - 16) / 2,
          y: el.y + el.h / 2 - textHeight / 2,
          width: el.w - 16,
          height: textHeight,
          text: el.label,
          originalText: el.label,
          autoResize: true,
          fontSize: fontSize,
          fontFamily: 1,
          textAlign: "center",
          verticalAlign: "middle",
          containerId: el.id,
          strokeColor: "#e6edf3",
          backgroundColor: "transparent",
          fillStyle: "solid",
          strokeWidth: 1,
          roughness: 1,
          opacity: 100,
          angle: 0,
          seed: seed * 1000 + 2,
          lineHeight: 1.25,
          boundElements: [],
        });
      }
    } else if (el.type === 'arrow') {
      const pts = el.points || [[0, 0], [100, 0]];
      const startX = el.x + pts[0][0];
      const startY = el.y + pts[0][1];
      const relativePoints = pts.map((p, i) => 
        i === 0 ? [0, 0] : [p[0] - pts[0][0], p[1] - pts[0][1]]
      );
      result.push({
        ...baseProps,
        type: "arrow",
        id: el.id,
        x: startX,
        y: startY,
        width: Math.abs(relativePoints[relativePoints.length - 1][0]),
        height: Math.abs(relativePoints[relativePoints.length - 1][1]),
        points: relativePoints,
        strokeColor: el.color || "#8b949e",
        backgroundColor: "transparent",
        fillStyle: "solid",
        strokeWidth: 2,
        roughness: 1,
        opacity: 100,
        angle: 0,
        seed: seed * 1000 + 3,
        endArrowhead: "arrow",
        startArrowhead: null,
        boundElements: [],
        roundness: { type: 2 },
      });
    } else if (el.type === 'text') {
      const fontSize = el.size || 16;
      const text = el.label || '';
      const lines = String(text).split('\n');
      result.push({
        ...baseProps,
        type: "text",
        id: el.id,
        x: el.x,
        y: el.y,
        width: text.length * fontSize * 0.6,
        height: lines.length * fontSize * 1.25,
        text: text,
        originalText: text,
        autoResize: true,
        fontSize: fontSize,
        fontFamily: 1,
        textAlign: "left",
        verticalAlign: "top",
        containerId: null,
        strokeColor: el.color || "#e6edf3",
        backgroundColor: "transparent",
        fillStyle: "solid",
        strokeWidth: 1,
        roughness: 1,
        opacity: 100,
        angle: 0,
        seed: seed * 1000 + 4,
        lineHeight: 1.25,
        boundElements: [],
      });
    }
  });
  
  return result;
}

// Render elements to the Excalidraw component
function renderElements(elements) {
  currentExcalidrawElements = elements;
  const excalidrawEls = toExcalidrawElements(elements);
  
  const api = window.excalidrawAPI;
  if (api) {
    api.updateScene({
      elements: excalidrawEls,
      appState: { viewBackgroundColor: "#0d1117" }
    });
    setTimeout(() => {
      if (window.excalidrawAPI) {
        window.excalidrawAPI.scrollToContent(excalidrawEls, { fitToContent: true, animate: false, duration: 0 });
      }
    }, 50);
  }
  
  document.getElementById('canvas-label').textContent = `Canvas ¬∑ ${elements.length} elements`;
}

// Re-zoom canvas on resize/orientation change
let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => {
    if (window.excalidrawAPI) {
      const els = window.excalidrawAPI.getSceneElements();
      if (els && els.length) {
        window.excalidrawAPI.scrollToContent(els, { fitToContent: true, animate: true, duration: 300 });
      }
    }
  }, 200);
});

// Get all elements accumulated up to a stage index (inclusive)
function getElementsUpToStage(stageIndex) {
  const elMap = {};
  for (let i = 0; i <= stageIndex; i++) {
    (model.stages[i].elements || []).forEach(el => { elMap[el.id] = el; });
  }
  return Object.values(elMap);
}

function selectModel(key) {
  if (!DATA[key]) return;
  stop();
  model = DATA[key];
  stageIdx = 0; elapsed = 0;
  currentExcalidrawElements = [];
  totalDuration = model.stages.reduce((s, st) => s + st.time_ms, 0);
  
  const pips = document.getElementById('pips');
  pips.innerHTML = '';
  model.stages.forEach((st, i) => {
    const p = document.createElement('div');
    p.className = 'pip' + (st.is_vision ? ' vision' : st.is_intervention ? ' intervention' : '');
    p.title = st.name;
    p.onclick = () => jumpStage(i);
    pips.appendChild(p);
  });
  
  document.getElementById('chat').innerHTML = '';
  
  // Show first stage diagram immediately
  const firstElements = model.stages[0]?.elements || [];
  if (firstElements.length > 0) {
    renderElements(firstElements);
  } else {
    renderElements([]);
  }
  
  updateUI();
}

function fmtMs(ms) { const s = Math.floor(ms / 1000); return `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`; }

function updateUI() {
  if (!model) return;
  document.getElementById('timer').textContent = `${fmtMs(elapsed)} / ${fmtMs(totalDuration)}`;
  document.getElementById('pfill').style.width = `${(elapsed / totalDuration) * 100}%`;
  
  const stg = model.stages[stageIdx];
  const label = document.getElementById('stage-label');
  label.textContent = `Stage ${Math.min(stageIdx + 1, model.stages.length)}/${model.stages.length} ¬∑ ${stg?.name || 'Done'}`;
  label.className = 'stage-badge ' + (stg?.is_vision ? 'vision' : stg?.is_intervention ? 'intervention' : stg?.is_text_only ? 'review' : 'normal');
  
  document.querySelectorAll('.pip').forEach((p, i) => {
    const base = model.stages[i]?.is_vision ? 'pip vision' : model.stages[i]?.is_intervention ? 'pip intervention' : 'pip';
    p.className = i < stageIdx ? base + ' done' : i === stageIdx ? base + ' current' : base;
  });
  
  const b = document.getElementById('badge');
  if (stg?.is_vision && playing) { b.textContent = 'üëÅÔ∏è ' + stg.name; b.className = 'badge intervention'; }
  else if (stg?.is_intervention && playing) { b.textContent = 'üîß Intervention'; b.className = 'badge intervention'; }
  else if (playing) { b.textContent = stg?.name || 'Playing'; b.className = 'badge playing'; }
  else if (stageIdx >= model.stages.length) { b.textContent = 'Complete'; b.className = 'badge done'; }
  else { b.textContent = 'Ready'; b.className = 'badge ready'; }
}

// PLAYBACK
function togglePlay() { if (playing) stop(); else startPlay(); }

function startPlay() {
  if (!model) return;
  if (stageIdx >= model.stages.length) {
    stageIdx = 0; elapsed = 0; currentExcalidrawElements = [];
    document.getElementById('chat').innerHTML = '';
    renderElements([]);
  }
  playing = true;
  document.getElementById('play-btn').textContent = '‚è∏';
  document.getElementById('play-btn').className = 'play-btn playing';
  // Auto-open drawer to peek when playing
  const drawer = document.getElementById('drawer');
  if (!drawer.classList.contains('open') && !drawer.classList.contains('peek')) {
    drawer.classList.add('peek');
  }
  beginStage();
}

function stop() {
  playing = false;
  cancelAnimationFrame(animFrame);
  document.getElementById('play-btn').textContent = '‚ñ∂';
  document.getElementById('play-btn').className = 'play-btn';
  document.querySelectorAll('.cursor').forEach(c => c.remove());
  updateUI();
}

function beginStage() {
  if (!playing || stageIdx >= model.stages.length) { stop(); updateUI(); return; }
  const stage = model.stages[stageIdx];
  
  const promptType = stage.is_vision ? 'vision-prompt' : stage.is_intervention ? 'interviewer' : 'human';
  const promptSender = stage.is_vision ? 'üëÅÔ∏è Vision Test' : stage.is_intervention ? 'üîß Interviewer (modifying canvas)' : 'üßë Interviewer';
  const promptDisplay = stage.is_intervention 
    ? stage.prompt.split('\n').slice(0, 3).join('\n') + '\n...(canvas modifications applied)'
    : stage.is_vision ? 'üì∑ [diagram screenshot attached]\n\n' + stage.prompt : stage.prompt;
  addChat(promptType, promptSender, promptDisplay);
  
  const thinkId = addChat('model', 'ü§ñ ' + (model.name || model.model), '', true);
  stageStartTime = performance.now();
  textCharIdx = 0;
  tickStage(stage, thinkId);
}

function tickStage(stage, thinkId) {
  if (!playing) return;
  const realElapsed = (performance.now() - stageStartTime) * speed;
  const stageDuration = stage.time_ms;
  const reasoning = stage.reasoning || '';
  const elements = stage.elements || [];
  
  const elemPhase = stage.is_text_only ? 0 : stageDuration * 0.3;
  const textPhase = stageDuration - elemPhase;
  
  // Phase 1: Elements appearing progressively
  if (!stage.is_text_only && elements.length > 0 && realElapsed < elemPhase) {
    const shouldShow = Math.min(elements.length, Math.floor(realElapsed / (elemPhase / elements.length)));
    if (shouldShow > textCharIdx) {
      const prevEls = stageIdx > 0 ? getElementsUpToStage(stageIdx - 1) : [];
      const currentPartial = elements.slice(0, shouldShow);
      renderElements([...prevEls, ...currentPartial]);
      textCharIdx = shouldShow;
    }
  }
  
  // Phase 2: Text streaming (and show all elements)
  if (realElapsed >= elemPhase) {
    if (!stage.is_text_only && elements.length > 0 && textCharIdx < elements.length) {
      const prevEls = stageIdx > 0 ? getElementsUpToStage(stageIdx - 1) : [];
      renderElements([...prevEls, ...elements]);
      textCharIdx = elements.length;
    }
    if (reasoning.length > 0) {
      const textElapsed = realElapsed - elemPhase;
      const targetChars = Math.min(reasoning.length, Math.floor(textElapsed * reasoning.length / textPhase));
      updateStreamingMsg(thinkId, reasoning, targetChars, stage);
    }
  }
  
  const stageProgress = Math.min(realElapsed, stageDuration);
  const prevTime = model.stages.slice(0, stageIdx).reduce((s, st) => s + st.time_ms, 0);
  elapsed = prevTime + stageProgress;
  updateUI();
  
  if (realElapsed >= stageDuration) {
    finalizeMsg(thinkId, stage);
    stageIdx++;
    updateUI();
    setTimeout(() => beginStage(), 400 / speed);
    return;
  }
  animFrame = requestAnimationFrame(() => tickStage(stage, thinkId));
}

// CHAT
function addChat(type, sender, text, isThinking) {
  const chat = document.getElementById('chat');
  const div = document.createElement('div');
  const id = `msg-${msgCounter++}`;
  div.id = id;
  div.className = `msg ${type}${isThinking ? ' thinking' : ''}`;
  const senderClass = type === 'vision-prompt' ? 'vision-name' : type === 'interviewer' ? 'interviewer-name' : type === 'human' ? 'human-name' : 'model-name';
  if (isThinking) {
    div.innerHTML = `<div class="sender ${senderClass}">${sender}</div><span class="dots"></span>`;
  } else {
    const escaped = text.replace(/</g, '&lt;').replace(/\n/g, '<br>');
    div.innerHTML = `<div class="sender ${senderClass}">${sender}</div><div class="reasoning">${escaped}</div>`;
  }
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
  return id;
}

function updateStreamingMsg(id, fullText, charCount, stage) {
  const el = document.getElementById(id);
  if (!el) return;
  el.className = 'msg model';
  const senderName = 'ü§ñ ' + (model.name || model.model);
  const partial = fullText.substring(0, charCount).replace(/</g, '&lt;').replace(/\n/g, '<br>');
  let diagramNote = '';
  if (!stage.is_text_only && stage.element_count > 0) {
    diagramNote = `<div class="diagram-note">üìê Canvas updated: <span class="count">${stage.element_count} elements</span></div>`;
  }
  el.innerHTML = `<div class="sender model-name">${senderName}</div>${diagramNote}<div class="reasoning">${partial}<span class="cursor"></span></div>`;
  document.getElementById('chat').scrollTop = document.getElementById('chat').scrollHeight;
}

function finalizeMsg(id, stage) {
  const el = document.getElementById(id);
  if (!el) return;
  el.className = 'msg model';
  const senderName = 'ü§ñ ' + (model.name || model.model);
  const reasoning = (stage.reasoning || '(no reasoning provided)').replace(/</g, '&lt;').replace(/\n/g, '<br>');
  let diagramNote = '';
  if (!stage.is_text_only && stage.element_count > 0) {
    diagramNote = `<div class="diagram-note">üìê Canvas updated: <span class="count">${stage.element_count} elements</span></div>`;
  }
  const secs = (stage.time_ms / 1000).toFixed(1);
  const tokens = stage.tokens ? ` ¬∑ ${stage.tokens.completion_tokens || '?'} tokens` : '';
  el.innerHTML = `<div class="sender model-name">${senderName}</div>${diagramNote}<div class="reasoning">${reasoning}</div><div class="meta"><span>‚è± ${secs}s${tokens}</span><span>${stage.is_vision ? 'üëÅÔ∏è vision test' : stage.is_intervention ? 'üîß intervention response' : stage.is_text_only ? 'üìù design review' : 'üìê layout + reasoning'}</span></div>`;
  document.getElementById('chat').scrollTop = document.getElementById('chat').scrollHeight;
}

// CONTROLS
function jumpStage(target) {
  stop();
  document.getElementById('chat').innerHTML = '';
  currentExcalidrawElements = [];
  elapsed = 0;
  
  for (let i = 0; i <= target; i++) {
    const stage = model.stages[i];
    const promptType = stage.is_intervention ? 'interviewer' : 'human';
    const promptSender = stage.is_intervention ? 'üîß Interviewer' : 'üßë Interviewer';
    addChat(promptType, promptSender, stage.prompt.substring(0, 200) + (stage.prompt.length > 200 ? '...' : ''));
    const msgId = addChat('model', 'ü§ñ ' + (model.name || model.model), '');
    finalizeMsg(msgId, stage);
    elapsed += stage.time_ms;
  }
  
  const allEls = getElementsUpToStage(target);
  renderElements(allEls);
  
  stageIdx = target + 1;
  updateUI();
}

function seekTo(e) {
  const rect = e.target.getBoundingClientRect();
  const pct = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
  const targetMs = pct * totalDuration;
  let acc = 0;
  for (let i = 0; i < model.stages.length; i++) {
    acc += model.stages[i].time_ms;
    if (acc >= targetMs) { jumpStage(i); return; }
  }
}

function resetReplay() {
  stop();
  stageIdx = 0; elapsed = 0; currentExcalidrawElements = [];
  document.getElementById('chat').innerHTML = '';
  if (model) {
    const firstElements = model.stages[0]?.elements || [];
    renderElements(firstElements.length > 0 ? firstElements : []);
  }
  updateUI();
}

function setSpeed() {
  speed = parseFloat(document.getElementById('speed').value);
  document.getElementById('speed-val').textContent = `${speed}√ó`;
}
</script>

<script>
const EXCALIDRAW_DATA = {
  "claude_opus_interview": {
  "model": "anthropic/claude-opus-4-6",
  "name": "Claude Opus 4 (Live Interview)",
  "has_vision": false,
  "stages": [
    {
      "name": "Initial Layout",
      "prompt": "We need a system architecture diagram for a modern web application with user authentication. Create the initial layout with labeled rectangles for each component: frontend, backend API, database, auth service, and file storage. Position them logically. Tell me your reasoning for the layout choices.",
      "time_ms": 8000,
      "valid": true,
      "element_count": 10,
      "reasoning": "I'm laying out the architecture in a classic top-down flow that mirrors how requests move through the system. The Frontend sits at the top center since it's the user's entry point ‚Äî everything starts here. Below it, the Backend API occupies the central position because it's the hub that orchestrates all communication between services. I've placed it with generous vertical spacing (180px gap) so there's room for arrows and labels.\n\nFor the bottom tier, I've arranged three components side by side: Auth Service on the left, Database in the center, and File Storage on the right. This horizontal spread at the bottom shows that these are all downstream services that the API talks to. Auth is separated to the left to visually distinguish it as a security concern rather than a data store. The Database and File Storage are grouped together on the center-right since they're both persistence layers. This three-column bottom row gives the diagram balance and makes the API's role as a central router visually obvious.",
      "elements": [
        {"type":"rectangle","id":"frontend","x":300,"y":80,"w":200,"h":80,"color":"#1971c2","bg":"#a5d8ff","label":"Frontend"},
        {"type":"text","id":"frontend-label","x":330,"y":105,"w":140,"h":30,"color":"#1971c2","bg":"transparent","label":"Frontend"},
        {"type":"rectangle","id":"backend-api","x":300,"y":260,"w":200,"h":80,"color":"#2f9e44","bg":"#b2f2bb","label":"Backend API"},
        {"type":"text","id":"api-label","x":320,"y":285,"w":160,"h":30,"color":"#2f9e44","bg":"transparent","label":"Backend API"},
        {"type":"rectangle","id":"auth-service","x":80,"y":440,"w":200,"h":80,"color":"#9c36b5","bg":"#d0bfff","label":"Auth Service"},
        {"type":"text","id":"auth-label","x":100,"y":465,"w":160,"h":30,"color":"#9c36b5","bg":"transparent","label":"Auth Service"},
        {"type":"rectangle","id":"database","x":300,"y":440,"w":200,"h":80,"color":"#e8590c","bg":"#ffd8a8","label":"Database"},
        {"type":"text","id":"db-label","x":345,"y":465,"w":110,"h":30,"color":"#e8590c","bg":"transparent","label":"Database"},
        {"type":"rectangle","id":"file-storage","x":540,"y":440,"w":200,"h":80,"color":"#e8590c","bg":"#ffd8a8","label":"File Storage"},
        {"type":"text","id":"fs-label","x":565,"y":465,"w":150,"h":30,"color":"#e8590c","bg":"transparent","label":"File Storage"}
      ],
      "is_intervention": false, "is_text_only": false, "is_vision": false
    },
    {
      "name": "Add Connections",
      "prompt": "Good start. Now add arrow elements showing the data flow between components. Users hit the frontend, frontend calls the API, API checks auth, API queries the database, API stores files. Explain the flow as you draw it ‚Äî which connections matter most and why?",
      "time_ms": 10000,
      "valid": true,
      "element_count": 16,
      "reasoning": "Now I'm adding the data flow arrows to show how requests propagate through the system. The primary flow is top-down: Users hit the Frontend, which calls the Backend API. I've drawn these as straight vertical arrows since they represent the critical path ‚Äî this is the most important connection because every single user interaction flows through it.\n\nFrom the API, three arrows fan out to the downstream services. The API-to-Auth arrow angles left to reach the Auth Service, representing the authentication check that happens on protected routes. The API-to-Database arrow drops straight down since the database is directly below ‚Äî this is the most frequently used connection for CRUD operations. The API-to-File-Storage arrow angles right, showing that file uploads and retrievals go to the separate storage service.\n\nI've color-coded the arrows to match their destination services: blue for the frontend path, purple for auth, and orange for the storage-related connections. This makes it easy to trace any particular flow visually. The fan-out pattern from the API clearly shows it as the orchestration layer ‚Äî it's the only component that talks to everything else, which is exactly what you'd expect in a well-designed API gateway pattern.",
      "elements": [
        {"type":"rectangle","id":"frontend","x":300,"y":80,"w":200,"h":80,"color":"#1971c2","bg":"#a5d8ff","label":"Frontend"},
        {"type":"text","id":"frontend-label","x":330,"y":105,"w":140,"h":30,"color":"#1971c2","bg":"transparent","label":"Frontend"},
        {"type":"rectangle","id":"backend-api","x":300,"y":260,"w":200,"h":80,"color":"#2f9e44","bg":"#b2f2bb","label":"Backend API"},
        {"type":"text","id":"api-label","x":320,"y":285,"w":160,"h":30,"color":"#2f9e44","bg":"transparent","label":"Backend API"},
        {"type":"rectangle","id":"auth-service","x":80,"y":440,"w":200,"h":80,"color":"#9c36b5","bg":"#d0bfff","label":"Auth Service"},
        {"type":"text","id":"auth-label","x":100,"y":465,"w":160,"h":30,"color":"#9c36b5","bg":"transparent","label":"Auth Service"},
        {"type":"rectangle","id":"database","x":300,"y":440,"w":200,"h":80,"color":"#e8590c","bg":"#ffd8a8","label":"Database"},
        {"type":"text","id":"db-label","x":345,"y":465,"w":110,"h":30,"color":"#e8590c","bg":"transparent","label":"Database"},
        {"type":"rectangle","id":"file-storage","x":540,"y":440,"w":200,"h":80,"color":"#e8590c","bg":"#ffd8a8","label":"File Storage"},
        {"type":"text","id":"fs-label","x":565,"y":465,"w":150,"h":30,"color":"#e8590c","bg":"transparent","label":"File Storage"},
        {"type":"arrow","id":"arrow-user-fe","x":400,"y":20,"color":"#1971c2","points":[[0,0],[0,60]]},
        {"type":"arrow","id":"arrow-fe-api","x":400,"y":160,"color":"#1971c2","points":[[0,0],[0,100]]},
        {"type":"arrow","id":"arrow-api-auth","x":300,"y":300,"color":"#9c36b5","points":[[0,0],[-120,140]]},
        {"type":"arrow","id":"arrow-api-db","x":400,"y":340,"color":"#e8590c","points":[[0,0],[0,100]]},
        {"type":"arrow","id":"arrow-api-fs","x":500,"y":300,"color":"#e8590c","points":[[0,0],[140,140]]},
        {"type":"text","id":"user-label","x":360,"y":10,"w":80,"h":25,"color":"#333333","bg":"transparent","label":"Users"}
      ],
      "is_intervention": false, "is_text_only": false, "is_vision": false
    },
    {
      "name": "Interviewer Intervention",
      "prompt": "I rearranged some things on the canvas. Changes I made: Minor position adjustments. I also want to add a load balancer in front of the frontend. What do you think of these layout changes? Update the diagram to incorporate a load balancer and fix anything that looks off.",
      "time_ms": 12000,
      "valid": true,
      "element_count": 19,
      "reasoning": "I see you've shifted things around slightly ‚Äî the positions are tweaked by 10-30px in various directions. That's fine, the overall structure holds up well. The main change I'm making is inserting a Load Balancer at the very top of the diagram, above the Frontend. This is the right architectural choice because in any production system, you'd want to distribute incoming traffic across multiple frontend instances.\n\nI've pushed everything down by about 120px to make room for the Load Balancer. It sits at the top in red (#e03131) to mark it as critical infrastructure ‚Äî if the LB goes down, everything goes down. The flow now reads: Users ‚Üí Load Balancer ‚Üí Frontend ‚Üí Backend API ‚Üí downstream services. I kept the load balancer slightly wider (220px vs 200px) to visually suggest that it's handling the full breadth of traffic before funneling it.\n\nThe rest of the layout stays the same structurally ‚Äî the three-column bottom tier for Auth, Database, and File Storage. I nudged the Frontend and API boxes 10px right to better center them under the wider load balancer. The arrow chain now has one extra hop at the top, which accurately reflects the real network path.",
      "elements": [
        {"type":"rectangle","id":"load-balancer","x":290,"y":80,"w":220,"h":70,"color":"#e03131","bg":"#ffc9c9","label":"Load Balancer"},
        {"type":"text","id":"lb-label","x":305,"y":100,"w":190,"h":30,"color":"#e03131","bg":"transparent","label":"Load Balancer"},
        {"type":"rectangle","id":"frontend","x":310,"y":210,"w":200,"h":80,"color":"#1971c2","bg":"#a5d8ff","label":"Frontend"},
        {"type":"text","id":"frontend-label","x":340,"y":235,"w":140,"h":30,"color":"#1971c2","bg":"transparent","label":"Frontend"},
        {"type":"rectangle","id":"backend-api","x":310,"y":380,"w":200,"h":80,"color":"#2f9e44","bg":"#b2f2bb","label":"Backend API"},
        {"type":"text","id":"api-label","x":330,"y":405,"w":160,"h":30,"color":"#2f9e44","bg":"transparent","label":"Backend API"},
        {"type":"rectangle","id":"auth-service","x":80,"y":560,"w":200,"h":80,"color":"#9c36b5","bg":"#d0bfff","label":"Auth Service"},
        {"type":"text","id":"auth-label","x":100,"y":585,"w":160,"h":30,"color":"#9c36b5","bg":"transparent","label":"Auth Service"},
        {"type":"rectangle","id":"database","x":310,"y":560,"w":200,"h":80,"color":"#e8590c","bg":"#ffd8a8","label":"Database"},
        {"type":"text","id":"db-label","x":355,"y":585,"w":110,"h":30,"color":"#e8590c","bg":"transparent","label":"Database"},
        {"type":"rectangle","id":"file-storage","x":550,"y":560,"w":200,"h":80,"color":"#e8590c","bg":"#ffd8a8","label":"File Storage"},
        {"type":"text","id":"fs-label","x":575,"y":585,"w":150,"h":30,"color":"#e8590c","bg":"transparent","label":"File Storage"},
        {"type":"text","id":"user-label","x":360,"y":20,"w":80,"h":25,"color":"#333333","bg":"transparent","label":"Users"},
        {"type":"arrow","id":"arrow-user-lb","x":400,"y":45,"color":"#e03131","points":[[0,0],[0,35]]},
        {"type":"arrow","id":"arrow-lb-fe","x":400,"y":150,"color":"#1971c2","points":[[0,0],[0,60]]},
        {"type":"arrow","id":"arrow-fe-api","x":410,"y":290,"color":"#1971c2","points":[[0,0],[0,90]]},
        {"type":"arrow","id":"arrow-api-auth","x":310,"y":420,"color":"#9c36b5","points":[[0,0],[-130,140]]},
        {"type":"arrow","id":"arrow-api-db","x":410,"y":460,"color":"#e8590c","points":[[0,0],[0,100]]},
        {"type":"arrow","id":"arrow-api-fs","x":510,"y":420,"color":"#e8590c","points":[[0,0],[140,140]]}
      ],
      "is_intervention": true, "is_text_only": false, "is_vision": false
    },
    {
      "name": "Style & Client Feedback",
      "prompt": "The client wants color-coding, Redis caching layer, CDN, and a title 'Web App Architecture'.",
      "time_ms": 15000,
      "valid": true,
      "element_count": 27,
      "reasoning": "The client wants color-coding, two new components (Redis and CDN), and a title. Let me walk through my reorganization. First, the title 'Web App Architecture' goes at the very top in large 36px text ‚Äî it anchors the whole diagram and gives it a professional, presentation-ready feel.\n\nFor color-coding, I'm using the specified palette: blue (#1971c2) for frontend-facing components (Frontend and CDN), green (#2f9e44) for the Backend API, orange (#e8590c) for storage layers (Database and File Storage), purple (#9c36b5) for Auth Service, and red (#e03131) for critical infrastructure (Load Balancer and Redis Cache). Redis gets red because a cache failure can cascade into database overload ‚Äî it's operationally critical.\n\nThe CDN sits in the top-left, parallel to the Load Balancer on the top-right. This shows two entry paths: static assets route through the CDN while dynamic requests go through the Load Balancer. Both converge on the Frontend. The Redis Cache is placed to the right of the Backend API at the same vertical level, showing it as a fast-path alternative to hitting the database directly. An arrow goes from API to Redis, and from Redis down to Database, illustrating the cache-aside pattern: check cache first, fall through to DB on miss.\n\nThe main trade-off is horizontal space. With CDN on the left and File Storage on the right, the diagram is now about 770px wide. I've kept the vertical flow tight (roughly 520px tall) to avoid scrolling. The three-tier structure is maintained: entry (CDN + LB), application (Frontend + API + Redis), and persistence (Auth + DB + Files).",
      "elements": [
        {"type":"text","id":"title","x":200,"y":10,"w":400,"h":50,"color":"#333333","bg":"transparent","label":"Web App Architecture"},
        {"type":"rectangle","id":"cdn","x":100,"y":100,"w":180,"h":60,"color":"#1971c2","bg":"#a5d8ff","label":"CDN"},
        {"type":"text","id":"cdn-label","x":145,"y":115,"w":90,"h":30,"color":"#1971c2","bg":"transparent","label":"CDN"},
        {"type":"rectangle","id":"load-balancer","x":340,"y":100,"w":220,"h":60,"color":"#e03131","bg":"#ffc9c9","label":"Load Balancer"},
        {"type":"text","id":"lb-label","x":365,"y":115,"w":170,"h":30,"color":"#e03131","bg":"transparent","label":"Load Balancer"},
        {"type":"rectangle","id":"frontend","x":310,"y":220,"w":200,"h":70,"color":"#1971c2","bg":"#a5d8ff","label":"Frontend"},
        {"type":"text","id":"frontend-label","x":345,"y":240,"w":130,"h":30,"color":"#1971c2","bg":"transparent","label":"Frontend"},
        {"type":"rectangle","id":"backend-api","x":310,"y":360,"w":200,"h":70,"color":"#2f9e44","bg":"#b2f2bb","label":"Backend API"},
        {"type":"text","id":"api-label","x":335,"y":380,"w":150,"h":30,"color":"#2f9e44","bg":"transparent","label":"Backend API"},
        {"type":"rectangle","id":"redis","x":570,"y":360,"w":180,"h":70,"color":"#e03131","bg":"#ffc9c9","label":"Redis Cache"},
        {"type":"text","id":"redis-label","x":600,"y":380,"w":120,"h":30,"color":"#e03131","bg":"transparent","label":"Redis Cache"},
        {"type":"rectangle","id":"auth-service","x":60,"y":520,"w":200,"h":70,"color":"#9c36b5","bg":"#d0bfff","label":"Auth Service"},
        {"type":"text","id":"auth-label","x":85,"y":540,"w":150,"h":30,"color":"#9c36b5","bg":"transparent","label":"Auth Service"},
        {"type":"rectangle","id":"database","x":310,"y":520,"w":200,"h":70,"color":"#e8590c","bg":"#ffd8a8","label":"Database"},
        {"type":"text","id":"db-label","x":355,"y":540,"w":110,"h":30,"color":"#e8590c","bg":"transparent","label":"Database"},
        {"type":"rectangle","id":"file-storage","x":570,"y":520,"w":200,"h":70,"color":"#e8590c","bg":"#ffd8a8","label":"File Storage"},
        {"type":"text","id":"fs-label","x":595,"y":540,"w":150,"h":30,"color":"#e8590c","bg":"transparent","label":"File Storage"},
        {"type":"text","id":"user-label","x":390,"y":60,"w":80,"h":25,"color":"#333333","bg":"transparent","label":"Users"},
        {"type":"arrow","id":"arrow-user-lb","x":430,"y":85,"color":"#333333","points":[[0,0],[0,15]]},
        {"type":"arrow","id":"arrow-cdn-fe","x":280,"y":130,"color":"#1971c2","points":[[0,0],[130,90]]},
        {"type":"arrow","id":"arrow-lb-fe","x":430,"y":160,"color":"#e03131","points":[[0,0],[0,60]]},
        {"type":"arrow","id":"arrow-fe-api","x":410,"y":290,"color":"#2f9e44","points":[[0,0],[0,70]]},
        {"type":"arrow","id":"arrow-api-auth","x":310,"y":400,"color":"#9c36b5","points":[[0,0],[-150,120]]},
        {"type":"arrow","id":"arrow-api-redis","x":510,"y":395,"color":"#e03131","points":[[0,0],[60,0]]},
        {"type":"arrow","id":"arrow-redis-db","x":660,"y":430,"color":"#e8590c","points":[[0,0],[-250,90]]},
        {"type":"arrow","id":"arrow-api-db","x":410,"y":430,"color":"#e8590c","points":[[0,0],[0,90]]},
        {"type":"arrow","id":"arrow-api-fs","x":510,"y":400,"color":"#e8590c","points":[[0,0],[160,120]]}
      ],
      "is_intervention": false, "is_text_only": false, "is_vision": false
    },
    {
      "name": "Design Review",
      "prompt": "Step back from the diagram. Walk through every component, what you'd change, weakest part, and 10x traffic plan.",
      "time_ms": 6000,
      "valid": true,
      "element_count": 0,
      "reasoning": "Let me walk through every component and connection in this architecture:\n\n**Components and Connections:**\nUsers enter through the Load Balancer, which distributes traffic to the Frontend. Static assets (images, CSS, JS) are served via the CDN, which sits alongside the LB as an entry point. The Frontend handles the UI layer and makes API calls down to the Backend API. The API is the central orchestrator ‚Äî it talks to three downstream services: the Auth Service (for login, token validation, and session management), the Database (for persistent CRUD operations), and File Storage (for uploaded media and documents). Redis Cache sits between the API and Database as a caching layer ‚Äî the API checks Redis first for frequently accessed data before falling through to the database.\n\n**What I'd change with more time:**\nI'd add a message queue (RabbitMQ or SQS) between the API and File Storage, because file processing should be async ‚Äî you don't want users waiting for image resizing or virus scanning. I'd also add a monitoring/observability layer (Prometheus + Grafana) as a sidebar component, and I'd show the response paths (not just request paths) with dashed arrows going back up. The diagram would also benefit from network boundary boxes ‚Äî a DMZ for the CDN/LB, a private subnet for the API tier, and an isolated data subnet for DB/Redis.\n\n**Weakest part of this architecture:**\nThe Auth Service is a single point of failure with no caching or redundancy shown. Every authenticated request hits it, which means if Auth goes down, the entire application is effectively down for logged-in users. It also lacks rate limiting or circuit breaker patterns ‚Äî a slow Auth Service would cascade failures back through the API to users. In a real system, you'd want Auth responses cached in Redis too, and you'd want the Auth Service itself to be horizontally scalable.\n\n**Handling 10x traffic tomorrow:**\nThe first thing I'd add is horizontal scaling for the Backend API ‚Äî put it behind its own load balancer with auto-scaling. The current single API box is the bottleneck. After that, I'd add read replicas for the Database (one write primary, multiple read replicas) and bump up Redis to a cluster. The Load Balancer at the top is already in place, so the frontend tier can scale by just adding instances. File Storage is likely already scalable if it's S3 or similar. The Auth Service would need to be replicated and its results cached aggressively in Redis with short TTLs.",
      "elements": [],
      "is_intervention": false, "is_text_only": true, "is_vision": false
    }
  ]
},
  "claude_opus_gold": {
    "model": "anthropic/claude-opus-4",
    "name": "Claude Opus 4 (Gold Standard)",
    "has_vision": false,
    "stages": [
      {
        "name": "Initial Layout",
        "prompt": "We need a system architecture diagram for a modern web application with user authentication. Create the initial layout with labeled rectangles for each component: frontend, backend API, database, auth service, and file storage. Position them logically. Tell me your reasoning for the layout choices.",
        "time_ms": 4500,
        "valid": true,
        "element_count": 10,
        "reasoning": "I'm using a three-tier layout with a clear left-to-right primary flow and top-to-bottom data gravity.\n\nThe Frontend sits at the far left (x=80) ‚Äî it's the entry point, where users arrive. Placing it leftmost follows the natural Western reading direction: you start here, then trace the flow rightward.\n\nThe Backend API goes center-stage at x=380. It's the orchestrator ‚Äî every other component talks through it. Centering it visually reinforces its role as the hub. I gave it slightly more height (110px vs 90px) to signal importance.\n\nAuth Service sits upper-right at x=680, y=80. It's a peer service to the API, not subordinate, so same vertical tier. But I offset it slightly higher to create visual separation from the storage layer below.\n\nDatabase goes lower-center at x=380, y=320 ‚Äî directly below the API it serves. This vertical alignment creates an implicit \"data flows down\" metaphor. PostgreSQL because it's the sensible default for auth-heavy apps.\n\nFile Storage (S3) sits lower-right at x=680, y=320 ‚Äî parallel to the database, reinforcing that both are persistence layers. The horizontal alignment between DB and File Storage says \"these are the same kind of thing.\"\n\nI left 300px horizontal gaps and 130px vertical gaps ‚Äî enough room for arrows and labels without crowding. The whole layout fits in a ~900√ó500 viewport, keeping everything visible without scrolling.",
        "elements": [
          {"type":"rectangle","id":"frontend","x":80,"y":160,"w":180,"h":90,"color":"#1971c2","bg":"#1971c222","label":"Frontend\n(React SPA)"},
          {"type":"rectangle","id":"backend","x":380,"y":150,"w":180,"h":110,"color":"#2f9e44","bg":"#2f9e4422","label":"Backend API\n(Node.js)"},
          {"type":"rectangle","id":"auth","x":680,"y":80,"w":180,"h":90,"color":"#9c36b5","bg":"#9c36b522","label":"Auth Service\n(OAuth2/JWT)"},
          {"type":"rectangle","id":"database","x":380,"y":320,"w":180,"h":90,"color":"#2f9e44","bg":"#2f9e4422","label":"Database\n(PostgreSQL)"},
          {"type":"rectangle","id":"file_storage","x":680,"y":320,"w":180,"h":90,"color":"#e8590c","bg":"#e8590c22","label":"File Storage\n(S3)"},
          {"type":"text","id":"lbl_user","x":30,"y":205,"label":"üë§","color":"#e6edf3","size":24},
          {"type":"text","id":"lbl_frontend_note","x":170,"y":270,"label":"Static assets served via CDN","color":"#484f58","size":10},
          {"type":"text","id":"lbl_api_note","x":470,"y":280,"label":"REST / GraphQL","color":"#484f58","size":10},
          {"type":"text","id":"lbl_auth_note","x":770,"y":185,"label":"Token validation","color":"#484f58","size":10},
          {"type":"text","id":"lbl_db_note","x":470,"y":425,"label":"Source of truth","color":"#484f58","size":10}
        ],
        "is_intervention": false, "is_text_only": false, "is_vision": false,
        "tokens": {"prompt_tokens":463,"completion_tokens":1200,"total_tokens":1663}
      },
      {
        "name": "Add Connections",
        "prompt": "Good start. Now add arrow elements showing the data flow between components. Users hit the frontend, frontend calls the API, API checks auth, API queries the database, API stores files. Explain the flow as you draw it ‚Äî which connections matter most and why?",
        "time_ms": 5200,
        "valid": true,
        "element_count": 20,
        "reasoning": "Let me trace the request lifecycle and draw each connection in order of criticality.\n\n**User ‚Üí Frontend** is the entry point. I'm drawing this as a short arrow from the left edge, with a user emoji as the origin. Every request starts here.\n\n**Frontend ‚Üí Backend API** is the most critical connection in the entire system. If this breaks, users see a blank page or infinite spinner. I'm using a thick blue arrow and labeling it 'HTTPS / REST' to emphasize it's the primary data channel. This arrow goes left-to-right, following the reading direction.\n\n**Backend API ‚Üí Auth Service** fires on every authenticated request. The API sends a token, Auth validates it, returns the user identity. I'm drawing this as a right-pointing arrow from API to Auth, labeled 'validate token'. This is synchronous and blocking ‚Äî if Auth is slow, everything is slow. That's why I'll note this as a potential bottleneck later.\n\n**Backend API ‚Üí Database** is the workhorse. Most API endpoints hit the DB. I'm drawing this as a vertical arrow straight down from API to Database, labeled 'queries / mutations'. The vertical direction reinforces the 'data flows down' metaphor. I'm also adding a faint return arrow (or noting it's bidirectional) because the DB returns result sets.\n\n**Backend API ‚Üí File Storage** is the least frequent connection ‚Äî only triggered for uploads, downloads, or serving user-generated content. Diagonal arrow, thinner, labeled 'upload / download'. This is often async (fire-and-forget for uploads, presigned URLs for downloads).\n\nNotably absent: **no direct Frontend ‚Üí Auth arrow**. The frontend never talks to Auth directly. All auth flows go through the API, which acts as a security boundary. This is intentional ‚Äî it prevents token leakage and ensures all auth logic lives server-side.\n\nAlso absent: **no Database ‚Üí File Storage arrow**. These are independent persistence layers. If you needed to store file metadata in the DB, that's the API's job to coordinate, not a direct DB‚ÜíS3 link.",
        "elements": [
          {"type":"rectangle","id":"frontend","x":80,"y":160,"w":180,"h":90,"color":"#1971c2","bg":"#1971c222","label":"Frontend\n(React SPA)"},
          {"type":"rectangle","id":"backend","x":380,"y":150,"w":180,"h":110,"color":"#2f9e44","bg":"#2f9e4422","label":"Backend API\n(Node.js)"},
          {"type":"rectangle","id":"auth","x":680,"y":80,"w":180,"h":90,"color":"#9c36b5","bg":"#9c36b522","label":"Auth Service\n(OAuth2/JWT)"},
          {"type":"rectangle","id":"database","x":380,"y":320,"w":180,"h":90,"color":"#2f9e44","bg":"#2f9e4422","label":"Database\n(PostgreSQL)"},
          {"type":"rectangle","id":"file_storage","x":680,"y":320,"w":180,"h":90,"color":"#e8590c","bg":"#e8590c22","label":"File Storage\n(S3)"},
          {"type":"text","id":"lbl_user","x":30,"y":205,"label":"üë§","color":"#e6edf3","size":24},
          {"type":"arrow","id":"a_user_fe","x":0,"y":0,"color":"#e6edf3","points":[[55,205],[80,205]]},
          {"type":"arrow","id":"a_fe_api","x":0,"y":0,"color":"#388bfd","points":[[260,200],[380,200]]},
          {"type":"text","id":"lbl_fe_api","x":295,"y":185,"label":"HTTPS / REST","color":"#388bfd","size":11},
          {"type":"arrow","id":"a_api_auth","x":0,"y":0,"color":"#9c36b5","points":[[560,155],[680,125]]},
          {"type":"text","id":"lbl_api_auth","x":600,"y":125,"label":"validate token","color":"#9c36b5","size":11},
          {"type":"arrow","id":"a_api_db","x":0,"y":0,"color":"#2f9e44","points":[[470,260],[470,320]]},
          {"type":"text","id":"lbl_api_db","x":485,"y":285,"label":"queries","color":"#2f9e44","size":11},
          {"type":"arrow","id":"a_api_fs","x":0,"y":0,"color":"#e8590c","points":[[560,230],[680,340]]},
          {"type":"text","id":"lbl_api_fs","x":610,"y":270,"label":"upload/\ndownload","color":"#e8590c","size":10},
          {"type":"text","id":"lbl_no_direct","x":500,"y":60,"label":"‚ö†Ô∏è No direct Frontend‚ÜíAuth path (by design)","color":"#484f58","size":10}
        ],
        "is_intervention": false, "is_text_only": false, "is_vision": false,
        "tokens": {"prompt_tokens":1663,"completion_tokens":1500,"total_tokens":3163}
      },
      {
        "name": "Interviewer Intervention",
        "prompt": "I rearranged some things on the canvas. I moved the database to bottom-center and pushed auth further right for more breathing room. I also want to add a load balancer in front of the frontend. What do you think of these changes? Update the diagram.",
        "time_ms": 5800,
        "valid": true,
        "element_count": 24,
        "reasoning": "Good instincts on both moves. Let me react to each:\n\n**Database to bottom-center** ‚Äî I actually like this better than what I had. Centering the DB at the bottom creates a visual 'foundation' metaphor. Everything rests on the data layer. It also makes the API‚ÜíDB arrow a clean vertical line straight down the middle of the diagram, which is the most important data path. My original position (directly under the API) was close to this, but true center at x=380 with more vertical separation is cleaner.\n\n**Auth pushed further right** ‚Äî This creates more breathing room in the middle tier, which was getting crowded. The extra horizontal gap between API and Auth also visually communicates that Auth is a separate service, not tightly coupled to the API. Good for microservices diagrams where you want to emphasize service boundaries.\n\n**Adding a Load Balancer** ‚Äî Essential for any production system. I'm placing it between the user and the frontend at x=80, and shifting the frontend right to x=250 to make room. The LB gets a distinct purple color (#9c36b5) to mark it as infrastructure rather than application logic.\n\nBut here's what I'd also fix now that we're rearranging:\n- The File Storage box needs to move too. With auth pushed right, there's an awkward gap. I'll align File Storage under the new auth position.\n- Arrow routes need updating to account for the new positions. The API‚ÜíDB arrow becomes a longer vertical drop, which actually looks more dramatic and important.\n- I'm adding a subtle dashed-style annotation showing the LB distributes to multiple frontend instances, hinting at horizontal scaling.",
        "elements": [
          {"type":"rectangle","id":"loadbalancer","x":50,"y":160,"w":140,"h":80,"color":"#9c36b5","bg":"#9c36b522","label":"Load\nBalancer"},
          {"type":"rectangle","id":"frontend","x":260,"y":160,"w":180,"h":90,"color":"#1971c2","bg":"#1971c222","label":"Frontend\n(React SPA)"},
          {"type":"rectangle","id":"backend","x":520,"y":150,"w":180,"h":110,"color":"#2f9e44","bg":"#2f9e4422","label":"Backend API\n(Node.js)"},
          {"type":"rectangle","id":"auth","x":830,"y":80,"w":180,"h":90,"color":"#9c36b5","bg":"#9c36b522","label":"Auth Service\n(OAuth2/JWT)"},
          {"type":"rectangle","id":"database","x":400,"y":440,"w":200,"h":100,"color":"#2f9e44","bg":"#2f9e4422","label":"Database\n(PostgreSQL)"},
          {"type":"rectangle","id":"file_storage","x":830,"y":320,"w":180,"h":90,"color":"#e8590c","bg":"#e8590c22","label":"File Storage\n(S3)"},
          {"type":"text","id":"lbl_user","x":15,"y":200,"label":"üë§","color":"#e6edf3","size":24},
          {"type":"arrow","id":"a_user_lb","x":0,"y":0,"color":"#e6edf3","points":[[35,200],[50,200]]},
          {"type":"arrow","id":"a_lb_fe","x":0,"y":0,"color":"#9c36b5","points":[[190,200],[260,200]]},
          {"type":"text","id":"lbl_lb_fe","x":205,"y":185,"label":"distribute","color":"#9c36b5","size":10},
          {"type":"arrow","id":"a_fe_api","x":0,"y":0,"color":"#388bfd","points":[[440,200],[520,200]]},
          {"type":"text","id":"lbl_fe_api","x":460,"y":185,"label":"REST","color":"#388bfd","size":11},
          {"type":"arrow","id":"a_api_auth","x":0,"y":0,"color":"#9c36b5","points":[[700,155],[830,125]]},
          {"type":"text","id":"lbl_api_auth","x":745,"y":125,"label":"validate","color":"#9c36b5","size":11},
          {"type":"arrow","id":"a_api_db","x":0,"y":0,"color":"#2f9e44","points":[[610,260],[500,440]]},
          {"type":"text","id":"lbl_api_db","x":530,"y":340,"label":"queries","color":"#2f9e44","size":11},
          {"type":"arrow","id":"a_api_fs","x":0,"y":0,"color":"#e8590c","points":[[700,230],[830,340]]},
          {"type":"text","id":"lbl_api_fs","x":750,"y":270,"label":"files","color":"#e8590c","size":10}
        ],
        "is_intervention": true, "is_text_only": false, "is_vision": false,
        "tokens": {"prompt_tokens":3163,"completion_tokens":1600,"total_tokens":4763}
      },
      {
        "name": "Style & Client Feedback",
        "prompt": "The client just got on the call. They want:\n1. Color-code each component by role (blue=frontend, green=API, orange=storage, purple=auth, red=critical)\n2. Add a Redis caching layer between the API and database\n3. Add a CDN in front of the frontend\n4. A big title at the top: 'Web App Architecture'\n\nWalk me through how you're reorganizing the layout to fit these new pieces.",
        "time_ms": 7200,
        "valid": true,
        "element_count": 32,
        "reasoning": "Four requests, let me work through the layout implications of each.\n\n**Title first** ‚Äî 'Web App Architecture' in 28px at the top center. This pushes everything down ~50px. Simple but it anchors the diagram and makes it presentation-ready. I'm using white text on the dark background.\n\n**CDN placement** ‚Äî CDN goes at the very left, before the Load Balancer. The request chain becomes: User ‚Üí CDN ‚Üí Load Balancer ‚Üí Frontend ‚Üí API. The CDN gets blue coloring (user-facing tier) but a slightly different shade (#1864ab, darker blue) to distinguish it from the frontend. I'm placing it at x=50, y=200 and pushing the LB and everything else rightward by ~80px.\n\n**Redis is the tricky one.** It sits between the API and Database, which means it needs to go in the vertical space between them. I'm placing it at x=540, y=350 ‚Äî horizontally centered under the API. The flow becomes: API ‚Üí Redis (cache check) ‚Üí if miss ‚Üí Database. I'm using red (#e03131) for Redis since the client said 'red=critical' and Redis going down would cripple performance. The arrow from API to Redis is vertical, and Redis to Database is another short vertical drop.\n\n**Color-coding overhaul:**\n- Blue (#1971c2): CDN, Frontend ‚Äî user-facing edge layer\n- Green (#2f9e44): Backend API ‚Äî application logic\n- Purple (#9c36b5): Auth Service, Load Balancer ‚Äî infrastructure/security\n- Orange (#e8590c): File Storage ‚Äî object storage\n- Red (#e03131): Redis ‚Äî critical infrastructure (cache failure = performance collapse)\n- Green for Database stays ‚Äî it's the data tier, same family as the API\n\n**Layout now has four clear rows:**\n1. Title (y=40)\n2. Edge tier: CDN ‚Üí LB ‚Üí Frontend (y=140)\n3. Application tier: Backend API ‚Üí Auth (y=140, right section)\n4. Data tier: Redis ‚Üí Database, File Storage (y=350-490)\n\nThe horizontal flow (left-to-right) shows the request path. The vertical flow (top-to-bottom) shows the data gravity ‚Äî requests come in at the top, data settles at the bottom. This dual-axis layout tells two stories simultaneously.",
        "elements": [
          {"type":"text","id":"title","x":480,"y":35,"label":"Web App Architecture","color":"#e6edf3","size":28},
          {"type":"rectangle","id":"cdn","x":30,"y":140,"w":110,"h":70,"color":"#1864ab","bg":"#1864ab22","label":"CDN"},
          {"type":"rectangle","id":"loadbalancer","x":180,"y":140,"w":120,"h":70,"color":"#9c36b5","bg":"#9c36b522","label":"Load\nBalancer"},
          {"type":"rectangle","id":"frontend","x":340,"y":130,"w":160,"h":90,"color":"#1971c2","bg":"#1971c222","label":"Frontend\n(React SPA)"},
          {"type":"rectangle","id":"backend","x":560,"y":120,"w":170,"h":110,"color":"#2f9e44","bg":"#2f9e4422","label":"Backend API\n(Node.js)"},
          {"type":"rectangle","id":"auth","x":830,"y":120,"w":160,"h":90,"color":"#9c36b5","bg":"#9c36b522","label":"Auth Service\n(OAuth2/JWT)"},
          {"type":"rectangle","id":"redis","x":540,"y":310,"w":160,"h":80,"color":"#e03131","bg":"#e0313122","label":"Redis Cache"},
          {"type":"rectangle","id":"database","x":430,"y":460,"w":180,"h":100,"color":"#2f9e44","bg":"#2f9e4422","label":"Database\n(PostgreSQL)"},
          {"type":"rectangle","id":"file_storage","x":830,"y":310,"w":160,"h":80,"color":"#e8590c","bg":"#e8590c22","label":"File Storage\n(S3)"},
          {"type":"text","id":"lbl_user","x":10,"y":175,"label":"üë§","color":"#e6edf3","size":20},
          {"type":"arrow","id":"a_cdn_lb","x":0,"y":0,"color":"#9c36b5","points":[[140,175],[180,175]]},
          {"type":"arrow","id":"a_lb_fe","x":0,"y":0,"color":"#9c36b5","points":[[300,175],[340,175]]},
          {"type":"arrow","id":"a_fe_api","x":0,"y":0,"color":"#388bfd","points":[[500,175],[560,175]]},
          {"type":"arrow","id":"a_api_auth","x":0,"y":0,"color":"#9c36b5","points":[[730,155],[830,155]]},
          {"type":"arrow","id":"a_api_redis","x":0,"y":0,"color":"#e03131","points":[[645,230],[620,310]]},
          {"type":"arrow","id":"a_redis_db","x":0,"y":0,"color":"#2f9e44","points":[[600,390],[520,460]]},
          {"type":"arrow","id":"a_api_fs","x":0,"y":0,"color":"#e8590c","points":[[730,210],[830,340]]},
          {"type":"text","id":"lbl_cdn_lb","x":145,"y":158,"label":"route","color":"#484f58","size":9},
          {"type":"text","id":"lbl_fe_api2","x":510,"y":158,"label":"REST","color":"#388bfd","size":10},
          {"type":"text","id":"lbl_api_auth2","x":765,"y":140,"label":"validate","color":"#9c36b5","size":10},
          {"type":"text","id":"lbl_api_redis","x":650,"y":265,"label":"cache check","color":"#e03131","size":10},
          {"type":"text","id":"lbl_redis_db","x":525,"y":420,"label":"cache miss","color":"#2f9e44","size":10},
          {"type":"text","id":"lbl_api_fs2","x":775,"y":265,"label":"files","color":"#e8590c","size":10},
          {"type":"text","id":"lbl_tier_edge","x":85,"y":225,"label":"‚îÄ‚îÄ Edge Tier ‚îÄ‚îÄ","color":"#484f5866","size":9},
          {"type":"text","id":"lbl_tier_data","x":620,"y":440,"label":"‚îÄ‚îÄ Data Tier ‚îÄ‚îÄ","color":"#484f5866","size":9}
        ],
        "is_intervention": false, "is_text_only": false, "is_vision": false,
        "tokens": {"prompt_tokens":4763,"completion_tokens":2000,"total_tokens":6763}
      },
      {
        "name": "Design Review",
        "prompt": "Step back from the diagram. Walk me through every component, what you'd change with more time, the weakest part, and what you'd add first for 10x traffic.",
        "time_ms": 6000,
        "valid": true,
        "element_count": 0,
        "reasoning": "**Component walkthrough:**\n\nTraffic enters through the CDN, which serves cached static assets (JS bundles, images, fonts) from edge nodes close to the user. Cache hits never touch our infrastructure. For a React SPA, this handles ~90% of the initial page load.\n\nThe Load Balancer distributes dynamic requests across frontend instances. In production this would be an ALB or Nginx, doing health checks and SSL termination. Right now it's a single box, but it represents a horizontally-scalable layer.\n\nThe Frontend is a React SPA ‚Äî technically it's just static files after build. The \"Frontend\" box really represents the client-side application running in the browser. The server just serves the bundle; all rendering happens client-side.\n\nThe Backend API is the brain. Every authenticated request flows through here. It validates tokens with Auth, checks Redis for cached data, falls through to PostgreSQL on cache miss, and coordinates file uploads to S3. It's the only component that talks to everything else.\n\nAuth Service handles OAuth2 flows, JWT issuance, and token validation. It's stateless by design ‚Äî all state lives in the tokens themselves or in the database. This means it scales horizontally trivially.\n\nRedis Cache sits between the API and Database. Hot data (session tokens, frequently-accessed records, rate limiting counters) lives here. Average read latency: ~1ms vs ~5-15ms for PostgreSQL. It's the difference between a snappy app and a sluggish one.\n\nPostgreSQL is the source of truth. All persistent data ‚Äî users, content, relationships, audit logs. ACID transactions, strong consistency. The foundation everything else builds on.\n\nS3 handles binary assets ‚Äî user uploads, generated PDFs, profile images. Effectively infinite storage with built-in redundancy.\n\n**What I'd change with more time:**\n1. Add a message queue (SQS/RabbitMQ) for async tasks ‚Äî email sending, image processing, webhook delivery. The API shouldn't block on these.\n2. Add an API Gateway in front of the Backend API for rate limiting, request transformation, and API key management.\n3. Show database read replicas ‚Äî a primary for writes, 2+ replicas for reads.\n4. Add monitoring/observability as a cross-cutting concern ‚Äî Prometheus, Grafana, structured logging. Every production system needs this.\n5. Add a WebSocket server for real-time features (notifications, live updates).\n\n**Weakest part:**\nThe Auth Service is a single point of failure with no caching. Every authenticated request makes a synchronous call to Auth. If Auth goes down or gets slow, the entire application grinds to a halt. Fix: cache validated tokens in Redis with a short TTL (5 minutes). Add a circuit breaker so that if Auth is unreachable, recently-validated tokens are still accepted. This trades a tiny security window for massive resilience.\n\n**For 10x traffic tomorrow:**\nFirst move: horizontal scaling of the Backend API. Spin up 10 instances behind the Load Balancer. The API is stateless (all state is in Redis/PostgreSQL), so this is pure configuration ‚Äî no code changes.\n\nSecond move: add PostgreSQL read replicas. Route all read queries to replicas, writes to primary. Most web apps are 90%+ reads, so this effectively 10x's database capacity.\n\nThird move: increase Redis cluster size and enable Redis Cluster mode for sharding. More memory = more cache hits = less database load.\n\nFourth move: CDN cache rules. Set aggressive cache headers for static assets and consider edge-side rendering (ESI) for semi-dynamic content.\n\nThe bottleneck at 10x would be database writes. If write volume is the issue, you need connection pooling (PgBouncer), write-ahead batching, or eventually sharding ‚Äî but that's a last resort. Start with the reads.",
        "elements": [],
        "is_intervention": false, "is_text_only": true, "is_vision": false,
        "tokens": {"prompt_tokens":6763,"completion_tokens":1800,"total_tokens":8563}
      }
    ]
  }
};
DATA = EXCALIDRAW_DATA;

// Init model select
(function() {
  const sel = document.getElementById('model-select');
  sel.innerHTML = '';
  Object.entries(DATA).forEach(([k, v]) => {
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = v.name || v.model || k;
    sel.appendChild(opt);
  });
})();
</script>

<script type="module">
import React from "https://esm.sh/react@18.3.1";
import { createRoot } from "https://esm.sh/react-dom@18.3.1/client?deps=react@18.3.1";
import { Excalidraw } from "https://esm.sh/@excalidraw/excalidraw@0.18.0?deps=react@18.3.1,react-dom@18.3.1";

const container = document.getElementById('excalidraw-container');
const root = createRoot(container);

const App = () => {
  const [api, setApi] = React.useState(null);
  
  const handleRef = React.useCallback((ref) => {
    if (ref) {
      window.excalidrawAPI = ref;
      setApi(ref);
      document.getElementById('loading').classList.add('hidden');
      
      const firstKey = Object.keys(DATA)[0];
      if (firstKey) {
        setTimeout(() => selectModel(firstKey), 100);
      }
      setSpeed();
    }
  }, []);
  
  return React.createElement(Excalidraw, {
    excalidrawAPI: handleRef,
    viewModeEnabled: true,
    zenModeEnabled: true,
    gridModeEnabled: false,
    theme: "dark",
    initialData: {
      appState: {
        viewBackgroundColor: "#0d1117",
        theme: "dark",
        gridSize: null,
      },
      elements: [],
    },
    UIOptions: {
      canvasActions: {
        changeViewBackgroundColor: false,
        clearCanvas: false,
        export: false,
        loadScene: false,
        saveToActiveFile: false,
        toggleTheme: false,
      },
      tools: { image: false },
    },
  });
};

root.render(React.createElement(App));
</script>
</body>
</html>
